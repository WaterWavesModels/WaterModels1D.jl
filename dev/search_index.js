var documenterSearchIndex = {"docs":
[{"location":"home/#WaterWaves1D.jl","page":"Home","title":"WaterWaves1D.jl","text":"","category":"section"},{"location":"home/#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"WaterWaves1D.jl is a Julia package providing a framework to study and compare several models for the propagation of unidimensional surface gravity waves (a.k.a. \"water waves\").","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"Several models are already implemented, including (but not limited to) the so-called water waves system, its truncated spectral expansion, the Green-Naghdi system, the Matsuno system, and so on. You may easily add your favorite one to the gang: see the how-to guide.","category":"page"},{"location":"home/#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"(v1.0) pkg> add https://github.com/WaterWavesModels/WaterWaves1D.jl.git\nusing WaterWaves1D","category":"page"},{"location":"home/#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"A simple example is documented here. More advanced examples can be found in the package's examples and notebooks section.","category":"page"},{"location":"home/#Developers","page":"Home","title":"Developers","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"WaterWaves1D.jl is being developed by Vincent Duchêne and Pierre Navaro.","category":"page"},{"location":"home/#Documentation-contents","page":"Home","title":"Documentation contents","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"Depth = 3\nPages = [\n        \"home.md\",\n        \"background.md\",\n        \"basics.md\",\n        \"example.md\",\n        \"index.md\"\n        ]","category":"page"},{"location":"basics/#Code-basics","page":"Code basics","title":"Code basics","text":"","category":"section"},{"location":"basics/","page":"Code basics","title":"Code basics","text":"Under construction","category":"page"},{"location":"basics/#How-to...","page":"Code basics","title":"How to...","text":"","category":"section"},{"location":"basics/","page":"Code basics","title":"Code basics","text":"WaterWaves1D.jl is meant to be versatile, and integrating new blocks to the package is easy. If you ever do so, please do not hesitate to contact the developers to either get help, or report on your advances.","category":"page"},{"location":"basics/#add-your-model","page":"Code basics","title":"add your model","text":"","category":"section"},{"location":"basics/","page":"Code basics","title":"Code basics","text":"Let us add the linear (Airy) water waves model whose equations are (using the same notations as here)","category":"page"},{"location":"basics/","page":"Code basics","title":"Code basics","text":"  leftbeginarrayl\n  _tη+fractanh(sqrtμ D)νsqrtμ D_xv=01ex\n  _tv+_xη=0\n  endarrayright","category":"page"},{"location":"basics/","page":"Code basics","title":"Code basics","text":"where F_1^μ= (here we use the notation F(D) for the action of pointwise multiplying by the function F in the Fourier space).","category":"page"},{"location":"basics/","page":"Code basics","title":"Code basics","text":"In a dedicated file we write","category":"page"},{"location":"basics/","page":"Code basics","title":"Code basics","text":"export Airy\nmutable struct Airy <: AbstractModel\n  label   :: String\n  f!      :: Function\n  mapto   :: Function\n  mapfro  :: Function\n\n  # We build our model here.\n\nend","category":"page"},{"location":"basics/","page":"Code basics","title":"Code basics","text":"Our purpose is to provide","category":"page"},{"location":"basics/","page":"Code basics","title":"Code basics","text":"label, a string used in subsequent informational messages, plots, etc.\nf! a function to be called in explicit time-integration solvers such as Euler or RK4 (one may provide other functions to be used with other solvers such as EulerSymp)\nWhithamBoussinesq.mapto a function which from  a couple (η,v) of type InitialData provides the raw data matrix on which computations are to be executed\nWhithamBoussinesq.mapfro the inverse function which from raw data returns (η,v).","category":"page"},{"location":"basics/","page":"Code basics","title":"Code basics","text":"To this aim, in place of the commented line, we write","category":"page"},{"location":"basics/","page":"Code basics","title":"Code basics","text":"function Airy(param::NamedTuple; # param is a NamedTuple containing all necessary parameters\n  label = \"linear (Airy)\"  # using a keyword argument allows the user to supersede the default label.\n   )\n\n  # Set up\n  μ = param.μ\n  if !in(:ν,keys(param)) # set default ν if it is not provided\n    ν = min(1,1/√μ)\n  else\n    ν = param.ν\n  end\n  # Collocation points and Fourier modes\n  m = Mesh(param)\n  x, k = m.x, m.k\n  # Fourier multipliers\n  ∂ₓ\t = 1im * k            # Differentiation\n  ∂ₓF₁ = 1im * tanh.(√μ*k)/(√μ*ν)\n  # Pre-allocation\n  fftη = zeros(Complex{Float64}, m.N)\n  fftv = zeros(Complex{Float64}, m.N)\n\n  # Evolution equations are ∂t U = f(U)\n  function f!(U)\n    fftη .= U[:,1]\n    fftv .= U[:,2]\n\n    U[:,1] .= -∂ₓF₁.*fftv\n    U[:,2] .= -∂ₓ.*fftη\n  end\n\n  # Build raw data from physical data (discrete Fourier transform)\n  function mapto(data::InitialData)\n    U = [fft(data.η(x)) fft(data.v(x))]\n  end\n\n  # Return physical data `(η,v)` from raw data\n  function mapfro(U)\n    real(ifft(U[:,1])),real(ifft(U[:,2]))\n  end\n\n  new( label, f!, mapto, mapfro )\nend","category":"page"},{"location":"basics/","page":"Code basics","title":"Code basics","text":"A useful tool used in the above was the function Mesh. It takes as argument a NamedTuple containing typically a number of points/modes and the (half-)size of the domain and provides the vector of collocations points and Fourier wavenumbers (see this discussion).","category":"page"},{"location":"basics/","page":"Code basics","title":"Code basics","text":"The Airy model can now be built as follows","category":"page"},{"location":"basics/","page":"Code basics","title":"Code basics","text":"using WaterWaves1D\n# include your file\nmodel = Airy((μ=1,L=2π,N=2^8))","category":"page"},{"location":"basics/#add-your-initial-data","page":"Code basics","title":"add your initial data","text":"","category":"section"},{"location":"basics/#add-your-solver","page":"Code basics","title":"add your solver","text":"","category":"section"},{"location":"background/#Background","page":"Background","title":"Background","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"Depth = 4\nPages = [ \"background.md\"  ]","category":"page"},{"location":"background/#Water-waves","page":"Background","title":"Water waves","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The propagation of waves at the surface of a layer of water is typically modelled using the incompressible Euler equations inside the fluid domain, and suitable boundary conditions at the boundaries (accounting for the impermeable bottom and the free surface).","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"In an idealized situation where the only external force acting on the fluid is due to the (constant) vertical gravity acceleration, that the fluid is homogeneous and the flow is potential (that is irrotational), the system can be written in closed form as two evolution equations.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Restricting to unidimensional waves (horizontal dimension d=1) in a domain without horizontal boundaries, assuming that the free surface can be described as the graph of a function which never touches the bottom (that is, non-cavitation) neglecting surface tension effects, assuming constant atmospheric pressure at the free surface and free slip boundary condition at the flat bottom, the equations in dimensionless variables read as follows (following notations in Lannes, Duchêne).","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\n  _tη-tfrac1μν G^μϵηψ=01ex\n  _tψ+η+fracϵ2ν(_xψ)^2-tfracϵμ2νfrac(frac1μ G^μϵηψ+ϵ(_xη)(_xψ))^21+μϵ²(_xη)^2=0\n  endarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where, by definition,","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"G^μϵηψ=big(_zPhi-μϵ(_xη)(_xΦ)big)bigvert_z=ϵη","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"with Φ being the unique solution to the elliptic boundary value problem","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"leftbeginarrayll\nμ _x^2 Φ + _z^2 Φ=0 text in  (xz)    -1zϵη(x)  \n Φ= ψ  text on  (xz)    z=ϵη(x) \n_z Φ=0  text on  (xz)    z=-1 \nendarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"In the above formula,","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"txz represent respectively the (rescaled) time, horizontal and vertical space variables.\nη represents the surface deformation: the free surface may be parametrized as (xz)   z=ϵη(x).\nψ is the trace of the velocity potential at the surface. In models we generally prefer to use v=ₓψ as the second unknown, since ψ is not necessarily decaying at (spatial) infinity even in finite-energy situations.\nϵ is the nonlinearity dimensionless parameter, defined as the ratio of the maximal amplitude of the wave to the depth of the layer.\nμ is the shallowness dimensionless parameter, defined as the square of the ratio of the depth of the layer to the typical horizontal wavelength of the flow.\nν is a scaling parameter: in shallow water situations one typically sets ν=1 while in deep water situations it is wise to set ν=1sqrtμ. In the latter case, ϵsqrtμ being the steepness of the wave plays an important role. Especially, taking formally the limit μ one obtains the infinite-depth situation where the wave steepness is the only remaining parameter.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"While the above formulation (due to Zakharov and Craig and Sulem) is very elegant, it is not directly suitable for efficient numerical simulations, due to the costly time-dependent elliptic problem involved in the Dirichlet-to-Neumann operator, G^μ. In our unidimensional framework, it is possible to make use of conformal mapping so as to rewrite the system using only pointwise operations or Fourier multipliers (that is pointwise operations in Fourier space). This allows, by means of the Fast Fourier Transform (FFT) and its inverse (IFFT), to provide a very efficient strategy for the numerical simulation of the water waves system. This strategy has been described for instance in Dyachenko et al. and Choi and Camassa.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The resulting code is WaterWaves.","category":"page"},{"location":"background/#Models","page":"Background","title":"Models","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"Because the above method is relatively recent (in comparison with early studies on water waves), imperfect (it suffers from \"anti-resolution\" for large-amplitude waves: the location of gridpoints spread out near wave crests, which in practice may demand the use of a very large number of modes to resolve the flow accurately), and restricted to unidimensional waves, many simplified models have been introduced in the literature. It is the aim of this package to provide a home for some of them.","category":"page"},{"location":"background/#Shallow-water-models","page":"Background","title":"Shallow water models","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"Shallow water models are expected to provide valid approximation to the water waves system for small values of the shallowness parameter, μ1 (in this case, ν=1).","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Many of these models are derived and discussed in Duchêne.","category":"page"},{"location":"background/#The-Saint-Venant-system","page":"Background","title":"The Saint-Venant system","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The Saint-Venant system is one of the oldest model for the propagation of water waves. It reads","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\n  _tη+_x((1+ϵη)v)=01ex\n  _tv+_xη+ϵv_xv=0\n  endarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Notice that the parameter μ has disappeared: the Saint-Venant system is the order-zero shallow water model for water waves.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The associated code is SaintVenant.","category":"page"},{"location":"background/#The-Boussinesq-systems","page":"Background","title":"The Boussinesq systems","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The abcd-Boussinesq systems refers to the full class of equations described by Bona, Chen and Saut","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\n  _tη+_x((1+ϵη)u)+a_x^3u-b_x^2_tη=01ex\n  _tu+_xη+ϵu_xu+c_x^3η-d_x^2_tu=0\n  endarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where abcd can be freely chosen as long as they satisfy a+b+c+d=13.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The associated code Boussinesq is restricted to the so-called Hamiltonian case, b=d, and c=0.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Indeed, in that case, one may genuinely interpret v=u-d_x^2u as an approximation to _xψ, the derivative of the trace of the velocity potential at the surface, and write the system as evolution equations for the variables (ηv):","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\n  _tη+_x((1+a_x^2)(1-b_x^2)^-2v + ϵ(1-b_x^2)^-1 (η (1-b_x^2)^-1v))=01ex\n  _tv+_xη+tfracϵ2_x(((1-b_x^2)^-1v)^2) =0\n  endarrayright","category":"page"},{"location":"background/#The-Whitham-Boussinesq-systems","page":"Background","title":"The Whitham-Boussinesq systems","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The Whitham-Boussinesq systems can be viewed as modified Boussinesq systems in view of fully recovering the dispersive properties of the water waves system. In other words, in the linear framework, that is setting ϵ=0, the model coincides with the linearized water waves system.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Specifically, we consider systems of the form","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\n  _tη+_x(F_1^μv + ϵ F_2^μ (η F_2^μv))=01ex\n  _tv+_xη+tfracϵ2_x((F_2^μv)^2) =0\n  endarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"with F_1^μ=fractanh(sqrtμ D)sqrtμ D, and F_2^μ=(F_1^μ)^α (here we use the notation F(D) for the action of pointwise multiplying by the function F in the Fourier space). The case α = 1 has been introduced by Dinvay, Dutykh and Kalisch, more general situations have been studied by Emerald.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The associated code is WhithamBoussinesq.","category":"page"},{"location":"background/#The-Green-Naghdi-system","page":"Background","title":"The Green-Naghdi system","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The (Serre-)Green-Naghdi system (Serre, Su and Gardner, Green and Naghdi) is sometimes called \"fully nonlinear Boussinesq system\" and is expected to provide a better approximation when the parameter ϵ is large.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"One of its many formulations is","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\n  _tη+_xbig( h ubig)=01ex\n  _tv+_xbig(η+ϵ uv - tfracϵ2u^2-tfracμϵ2 (h_xu)^2big) =0\n  endarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where h=1 + ϵ η is the depth, v=_xψ the derivative of the trace of the velocity potential at the surface, and u the layer-averaged horizontal velocity obtained by solving the elliptic problem","category":"page"},{"location":"background/","page":"Background","title":"Background","text":" hu -tfracμ3_x( h^3 _xu) = hv","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The associated code is SerreGreenNaghdi.","category":"page"},{"location":"background/#The-square-root-depth-system","page":"Background","title":"The square-root depth system","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The \"√D\" system proposed by Cotter, Holm and Percival can be written as","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\n  _tη+_xbig( h ubig)=01ex\n  _tv+_xbig(η+tfracϵ2v^2+tfracμϵ6h^2 (_x(hu))^2big) =0\n  endarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where h=1 + ϵ η is the depth, v=_xψ the derivative of the trace of the velocity potential at the surface, and u is obtained by solving the elliptic problem","category":"page"},{"location":"background/","page":"Background","title":"Background","text":" u -tfracμ3_x( h^-1 _x(hu)) = v","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The associated code is SquareRootDepth.","category":"page"},{"location":"background/#The-\"non-hydrostatic\"-system","page":"Background","title":"The \"non-hydrostatic\" system","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The \"non-hydrostatic\" system proposed by Bristeau, Mangeney, Sainte-Marie and Seguin can be written as","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\n  _tη+_xbig( h ubig)=01ex\n  _tv+_xbig(η+tfracϵ2v^2+tfracμϵ2 ( w_x^2(hu) + _x^2( hu w ) + ϵ (_xη)(_xw)u )big) =0\n  endarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where h=1 + ϵ η is the depth, v=_xψ the derivative of the trace of the velocity potential at the surface, w=-(h ₓu)2 and u is obtained by solving the elliptic problem","category":"page"},{"location":"background/","page":"Background","title":"Background","text":" hu -tfracμ4_x( h^3 _xu) = hv","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The associated code is NonHydrostatic.","category":"page"},{"location":"background/#The-Whitham-Green-Naghdi-system","page":"Background","title":"The Whitham-Green-Naghdi system","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The Whitham-Green-Naghdi system proposed by Duchêne, Israwi and Talhouk. can be viewed as a modified Green-Naghdi system in view of fully recovering the dispersive properties of the water waves system. In other words, in the linear framework, that is setting ϵ=0, the model coincides with the linearized water waves system.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\n  _tη+_xbig( h ubig)=01ex\n  _tv+_xbig(η+ϵ uv - tfracϵ2u^2-tfracμϵ2 (h F_0^μ_xu)^2big) =0\n  endarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where h=1 + ϵ η is the depth, v=_xψ the derivative of the trace of the velocity potential at the surface, and u the layer-averaged horizontal velocity obtained by solving the elliptic problem","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"hu -tfracμ3F_0^μ_x( h^3 F_0^μ_xu) = hv","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"with F_0^μ=sqrt3((F_1^μ)^-1(D) - 1)D where F_1^μ=fractanh(sqrtμ D)sqrtμ D (here we use the notation F(D) for the action of pointwise multiplying by the function F in the Fourier space).","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The associated code is WhithamBoussinesq.","category":"page"},{"location":"background/#The-Isobe-Kakinuma-systems","page":"Background","title":"The Isobe-Kakinuma systems","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The Isobe-Kakinuma model is a hierarchy of models proposed by Isobe, depending on the rank N and the parameters (p_0p_1p_N)","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\n  _tη+_xleft( sum_j=0^Ntfrach^p_j+1p_j+1_xϕ_j right)=01ex\n  _tv+_xleft( η\n  +ϵ left( sum_i=0^Np_ih^p_i-1ϕ_i right)_xleft( sum_j=0^Ntfrach^p_j+1p_j+1_xϕ_j right)\n  +tfracϵ2left( sum_j=0^Nh^p_j_xϕ_jright)^2\n  +tfracϵ2μ left( sum_j=0^Np_jh^p_j-1ϕ_jright)^2 right) =0\n  endarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where h=1 + ϵ η is the depth, v=_xψ the derivative of the trace of the velocity potential at the surface, and (ϕ₀ϕ₁ϕ_N) are obtained by solving the elliptic problem","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\nsum_j=0^Nh^p_jϕ_j =ψ1ex\n-h^p_i _xleft(sum_j=0^Ntfrach^p_j+1p_j+1_xϕ_j right)\n+ _xleft(sum_j=0^Ntfrach^p_i+p_j+1p_i+p_j+1_xϕ_j right)\n-tfrac1μ sum_j=0^N tfracp_ip_jp_i+p_j+1ϕ_j=0 quad (forall i1N)\n  endarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The associated code IsobeKakinuma is (for now) limited to the case N=1 and (p₀p₁)=(02).","category":"page"},{"location":"background/#Small-steepness-models","page":"Background","title":"Small steepness models","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"Small-steepness models rely on the smallness of the steepness dimensionless parameter, ϵsqrtμ1, and may be valid in shallow water as well as deep water configurations.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"In what follows we use the notation F(D) for the action of pointwise multiplying by the function F in the Fourier space. Specifically,","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"T^μ=-rm itanh(sqrtμ D)","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"is the \"Tilbert transform\" (related to the Hilbert transform, the latter arising in the infinite layer configuration, μ=).","category":"page"},{"location":"background/#The-Airy-equations","page":"Background","title":"The Airy equations","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The simplest small-steepness model is the linear Airy water waves obtained by setting ϵ=0 in the water waves system:","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\n  _tη-tfrac1sqrtμ ν T^μv =01ex\n  _tv+_xη=0\n  endarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where we denote v=_xψ the derivative of the trace of the velocity potential at the surface.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The associated code is Airy.","category":"page"},{"location":"background/#The-spectral-systems","page":"Background","title":"The spectral systems","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"Dommermuth and Yue, West et al., and Craig and Sulem have proposed a hierarchy of systems based on a \"spectral\" expansion, which can be interpreted through the Taylor expansion of the Dirichlet-to-Neumann, G^μϵηψ, with respect to the surface deformation variable:","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"G^μϵηψ=G^μ0ψ + ϵ (D_η G^μ0)(ϵη)ψ + ϵ^2 (D_η^2 G^μ0)(ϵηϵη)ψ + ","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The first nonlinear system of the hierarchy, incorporating only quadratic nonlinearities, is","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\n  _tη-tfrac1sqrtμ ν T^μv  + tfracϵν _xbig(η v +  T^μ(η T^μ v)big) =01ex\n  _tv+_xη+fracϵ2ν_xbig( v^2-(T^μv)^2big)=0\n  endarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where we denote v=_xψ the derivative of the trace of the velocity potential at the surface.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Higher order systems can be constructed using recursive formula. Explicit expressions up to quintic nonlinearities are given in Choi.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The associated code is WWn.","category":"page"},{"location":"background/#The-rectified-spectral-systems","page":"Background","title":"The rectified spectral systems","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"It turns out the spectral models above suffer from spurious instabilities; see Ambrose, Bona and Nicholls.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Duchêne and Melinand proposed a \"rectified\" quadratic model:","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\n  _tη-tfrac1sqrtμ ν T^μv  + tfracϵν _xbig((J^δη) v +  T^μ((J^δη) T^μ v)big) =01ex\n  _tv+_xη+fracϵ2ν_xJ^δbig( v^2-(T^μv)^2big)=0\n  endarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"with J^δ=J_0(δD) where J_0(k) approaches 1 for small wavenumbers, k, and approaches 0 for large wavenumbers; and the parameter δ can be freely chosen, but is typically of the size of tfracϵν. In the associated code, WWn, one has by default","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"J_0(k)=min(11k)","category":"page"},{"location":"background/#The-Matsuno-system","page":"Background","title":"The Matsuno system","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The model introduced by Matsuno is","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\n  _tη-tfrac1sqrtμ ν T^μu  + tfracϵν _x(η u) +  tfracϵν T^μ(η _x T^μ u) =01ex\n  _tu+big(1-ϵsqrtμ T^μ_xηbig)_xη+fracϵ2ν_xbig( u^2big)=0\n  endarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where u=_xψ-ϵsqrtμ(T^μ_xψ)(_xη) represents the horizontal velocity at the free surface.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The associated codes are Matsuno, and Matsuno_fast for a less human-readable but more efficient version.","category":"page"},{"location":"background/#The-modified-Matsuno-system","page":"Background","title":"The modified Matsuno system","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"In view of ensuring the stability of the equations, Duchêne and Melinand proposed a modified Matsuno system:","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\n  _tη-tfrac1sqrtμ ν T^μu  + tfracϵν _x(η u) +  tfracϵν T^μ(η _x T^μ u) =01ex\n  _tu+expbig(-ϵsqrtμ T^μ_xηbig)_xη+fracϵ2ν_xbig( u^2big)=0\n  endarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The associated codes is modifiedMatsuno.","category":"page"},{"location":"background/#The-Akers-Nicholls-system","page":"Background","title":"The Akers-Nicholls system","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The model introduced in Akers and Nicholls (see also Cheng, Granero-Belinchón, Shkoller and Milewski) can be written as","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"  leftbeginarrayl\n  _tη+_x m=01ex\n  _tm-tfrac1sqrtμ ν T^μbig(η+fracϵν(L^μ m)^2big)+fracϵνbig(η_xη+T^μ(η _x T^μ η)big)=0\n  endarrayright","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"with notations as above, L^μ=fracνsqrtμ Dtanh(sqrtμ D) and where m=-frac1sqrtμ ν T^μψ  + fracϵν big(η _xψ +  T^μ(η T^μ _xψ)big) represents the vertically integrated horizontal momentum.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The associated codes is AkersNicholls, and AkersNicholls_fast for a less human-readable but more efficient version.","category":"page"},{"location":"background/#Pseudospectral-methods","page":"Background","title":"Pseudospectral methods","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"Although this is not imperative of the package, all the codes mentioned above use Fourier-based pseudospectral methods for spatial discretization. This method is particularly suitable for data which are either periodic or decaying at infinity (in which case the function at stake is considered as periodic on a sufficiently large period), and fairly regular. In this framework one approaches 2L-periodic functions by finite Fourier sums of the form (assuming N even)","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"u(tx)sum_k=-N2^N2-1 a_k(t) e^rm i tfracπLk x","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"and seek a system of ordinary differential equations on the coefficients a_k(t) (which are then discretized in time by your favorite time solver).","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"In practice, given the values (u(x_j))_j0N-1 at the regularly spaced collocation points x_j= -L+2jtfracLN, one uses the discrete Fourier transform (computed efficiently with a Fast Fourier transform (FFT)) to deduce the corresponding coefficients a_k. Hence the coefficients are related to the coefficients of the (infinite) Fourier series","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"u(tx)=sum_k=-^ c_k(t) e^rm i tfracπLk x","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"through the relation","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"a_k(t) = sum_ℓinmathbbZ c_k+ℓN(t)","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Hence each of the coefficients a_k encompasses a full series of Fourier coefficients, which is unavoidable since e^rm i tfracπLk x and e^rm i tfracπL(k+ℓN) x are indistinguishable on the gridpoints xx_0x_N-1: this is called aliasing. Yet for smooth functions, Fourier coefficients rapidly decrease, and the error between the finite spectral decomposition and the infinite Fourier decomposition can often be made immaterial (that is to the order of machine precision rounding errors) when choosing a sufficient large number of modes, N.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"When using the finite spectral decomposition, the action of Fourier multipliers, and in particular spatial differentiation, is performed exactly (that is up to machine precision rounding errors) through corresponding multiplication on the discrete coefficients a_k, and only nonlinear contributions require some attention. The simplest way to approximately compute products (or any pointwise operations in the space variable) is by performing pointwise operations on values at collocation points which are obtained from the discrete coefficients using discrete inverse Fourier transform. For the sake of discussion, consider","category":"page"},{"location":"background/","page":"Background","title":"Background","text":" u^2(x_jt)  big(sum_k=-N2^N2-1 a_k(t) e^rm i tfracπLk x_jbig)^2\n = sum_m=-N2^N2-1sum_n=-N2^N2-1 a_m a_n e^rm i tfracπL(m+n) x_j","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"One infers","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"u^2(x_jt)  sum_k=-N2^N2-1 b_k(t) e^rm i tfracπLk x_j qquad b_k = sum_m+nin k-Nkk+Na_m a_n","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"In the above formula for b_k, some of the summands are spurious effects from aliasing, which sometimes contribute to numerical instabilities. In order to suppress such terms the so-called dealiasing consists in adding a sufficient number of modes with coefficients set to zero (in practice one often uses ideal low-pass filters, that is set to zero extreme modes, so as to always work with vectors with a fixed given length). The so-called Orszag's 3/2 rule states that, in the presence of quadratic nonlinearities, padding 3/2 modes (or zero-ing 1/3 modes) is sufficient to discard all spurious aliasing contributions, and provides in particular a Galerkin approximation since the error is orthogonal to all expansion functions.","category":"page"},{"location":"#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"","category":"page"},{"location":"#Initial-data","page":"Index","title":"Initial data","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Pages   = [ \"index/#initial-data.md\" ]","category":"page"},{"location":"","page":"Index","title":"Index","text":"Modules = [WaterWaves1D]\n#Filter = t -> typeof(t) === DataType && t <: InitialData # this filters out useful functions, so it is better to include specific pages\nPages = [\n\"CnoidalWaveSerreGreenNaghdi.jl\",\n\"SolitaryWaveSerreGreenNaghdi.jl\",\n\"SolitaryWaveWhithamGreenNaghdi.jl\",\n\"SolitaryWaveWhithamBoussinesq.jl\",\n\"SolitaryWaveWhitham.jl\",\n\"Random.jl\"]\n","category":"page"},{"location":"#WaterWaves1D.CnoidalSGN","page":"Index","title":"WaterWaves1D.CnoidalSGN","text":"CnoidalSGN(param; P=1)\n\nBuild the initial data associated with CnoidalWaveSerreGreenNaghdi(param; P=1), of type InitialData, to be used in initial-value problems Problem(model, initial::InitialData, param).\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.CnoidalWaveSerreGreenNaghdi-Tuple{NamedTuple}","page":"Index","title":"WaterWaves1D.CnoidalWaveSerreGreenNaghdi","text":"CnoidalWaveSerreGreenNaghdi(param; P=1)\n\nCompute the Serre-Green-Naghdi cnoidal wave with prescribed h₀<h₁<h₂. h₁ is the minimum, h₂ is the maximum of the wave. As h₀ -> h₁, the cnoidal wave converges towards the solitary wave. See for instance Gavrilyuk, Nkonga, Shyue and Truskinovsky, doi:10.1088/1361-6544/ab95ac\n\nArguments\n\nparam :: NamedTuple: parameters of the problem containing h₀<h₁<h₂ and dimensionless parameters ϵ and μ, and number of collocation points N.\nP :: Int: (keyword, optional, default = 1) the number of periods of the cnoidal wave in the constructed mesh.\n\nReturn values\n\n(η,u,v,mesh,param) with\n\nη :: Vector{Float64}: surface deformation;\nu :: Vector{Float64}: layer-averaged velocity;\nv :: Vector{Float64}: derivative of the trace of the velocity potential at the surface;\nmesh :: Mesh: mesh collocation points;\nparam :: NamedTuple: useful parameters\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.SolitarySGN","page":"Index","title":"WaterWaves1D.SolitarySGN","text":"SolitarySGN(param; x₀=0)\n\nBuild the initial data associated with SolitaryWaveSerreGreenNaghdi(param; x₀=0), of type InitialData, to be used in initial-value problems Problem(model, initial::InitialData, param).\n\n\n\nSolitarySGN(c; ϵ=1,μ=1,x₀=0,N=2^12)\n\nBuild the initial data with velocity c, center x₀, dimensionless parameters ϵ and μ, and number of collocation points N.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.SolitaryWaveSerreGreenNaghdi-Tuple{NamedTuple}","page":"Index","title":"WaterWaves1D.SolitaryWaveSerreGreenNaghdi","text":"SolitaryWaveSerreGreenNaghdi(param; x₀=0)\n\nCompute the Serre-Green-Naghdi solitary wave with prescribed velocity.\n\nArguments\n\nparam :: NamedTuple: parameters of the problem containing velocity c and dimensionless parameters ϵ and μ, and mesh size L and number of collocation points N;\nx₀ :: Real: (keyword, optional, default = 0) center of solitary wave.\n\nReturn values\n\n(η,u,v,mesh) with\n\nη :: Vector{Float64}: surface deformation;\nu :: Vector{Float64}: layer-averaged velocity;\nv :: Vector{Float64}: derivative of the trace of the velocity potential at the surface;\nmesh :: Mesh: mesh collocation points.\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.SolitaryWGN","page":"Index","title":"WaterWaves1D.SolitaryWGN","text":"SolitaryWGN(param; kwargs)\n\nBuild the initial data associated with SolitaryWaveWhithamGreenNaghdi(param; kwargs), of type InitialData, to be used in initial-value problems Problem(model, initial::InitialData, param).\n\n\n\nSolitaryWGN(c; ϵ=1,μ=1,N=2^12,kwargs)\n\nBuild the initial data with velocity c, dimensionless parameters ϵ and μ, and number of collocation points N, and kwargs the other (optional) keyword arguments as above.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.SolitaryWaveWhithamGreenNaghdi-Tuple{NamedTuple}","page":"Index","title":"WaterWaves1D.SolitaryWaveWhithamGreenNaghdi","text":"SolitaryWaveWhithamGreenNaghdi(param; kwargs)\n\nCompute the Whitham-Green-Naghdi solitary wave with prescribed velocity.\n\nArguments\n\nparam :: NamedTuple: parameters of the problem containing velocity c and dimensionless parameters ϵ and μ, and mesh size L and number of collocation points N;\n\nKeywords (optional)\n\nguess :: Vector{Real}: initial guess for the surface deformation (if not provided, the exact formula for SGN is used);\nx₀ :: Real: center of solitary wave (if guess is not provided);\nSGN :: Bool: if true computes the Serre-Green-Naghdi (instead of Whitham-Green-Naghdi) solitary wave (consider SolitaryWaveSerreGreenNaghdi instead);\nmethod :: Int: equation used (between 1 and 4);\niterative :: Bool: inverts Jacobian through GMRES if true, LU decomposition if false (default is false);\nverbose :: Bool: prints numerical errors at each step if true (default is false);\nmax_iter :: Int: maximum number of iterations of the Newton algorithm (default is 20);\ntol :: Real: relative tolerance measured in ℓ∞ norm (default is 1e-10);\nktol :: Real: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ngtol :: Real: relative tolerance of the GMRES algorithm (default is 1e-10);\ndealias :: Int: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nq :: Real: Newton algorithm modified with u_{n+1}=q*u_{n+1}+(1-q)*u_n (default is 1);\nα :: Real: adds α times spectral projection onto the Kernel to the Jacobian (default is 0).\n\nReturn values\n\n(η,u,v,mesh) with\n\nη :: Vector{Float64}: surface deformation;\nu :: Vector{Float64}: layer-averaged velocity;\nv :: Vector{Float64}: derivative of the velocity potential at the surface;\nmesh :: Mesh: mesh collocation points.\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.SolitaryWB","page":"Index","title":"WaterWaves1D.SolitaryWB","text":"SolitaryWB(param; kwargs)\n\nBuild the initial data associated with SolitaryWaveWhithamBoussinesq(param; kwargs), of type InitialData, to be used in initial-value problems Problem(model, initial::InitialData, param).\n\n\n\nSolitaryWB(c; ϵ=1,μ=1,N=2^12,kwargs)\n\nBuild the initial data with velocity c, dimensionless parameters ϵ and μ, and number of collocation points N, and kwargs the other (optional) keyword arguments as above.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.SolitaryWaveWhithamBoussinesq-Tuple{NamedTuple}","page":"Index","title":"WaterWaves1D.SolitaryWaveWhithamBoussinesq","text":"SolitaryWaveWhithamBoussinesq(param; kwargs)\n\nCompute the Whitham-Boussinesq solitary wave with prescribed velocity.\n\nArgument\n\nparam :: NamedTuple: parameters of the problem containing velocity c and dimensionless parameters ϵ and μ,\n\nand mesh size L and number of collocation points N;\n\nKeywords (optional)\n\nguess :: Vector{Real}: initial guess for the surface deformation (if not provided, the exact formula for SGN is used);\nx₀ :: Real: center of solitary wave (if guess is not provided);\nα :: Real: determines the model used (typically 1 or 1/2, default is 1);\nBoussinesq: if true (default is false), compute the standard Boussinesq system with parameters a (defaut -1//3), b=d (defaut 1//3), and c=0);\niterative :: Bool: inverts Jacobian through GMRES if true, LU decomposition if false;\nverbose :: Bool: prints numerical errors at each step if true;\nmax_iter :: Int: maximum number of iterations of the Newton algorithm;\ntol :: Real: general tolerance (default is 1e-10);\nktol :: Real: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ngtol :: Real: relative tolerance of the GMRES algorithm (default is 1e-10);\ndealias :: Int: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nq :: Real: Newton algorithm modified with\n\nu_{n+1}=q*(u_n+du)+(1-q)*u_n (default is 1);\n\nβ :: Real: adds β times spectral projection onto the Kernel to the Jacobian.β\n\nReturn values\n\n(η,v,mesh) with\n\nη :: Vector{Float64}: surface deformation;\nv :: Vector{Float64}: velocity (derivative of the trace of the velocity potential at the surface);\nmesh :: Mesh: mesh collocation points.\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.SolitaryWhitham","page":"Index","title":"WaterWaves1D.SolitaryWhitham","text":"SolitaryWhitham(param; kwargs)\n\nBuild the initial data associated with SolitaryWaveWhitham(param; kwargs), of type InitialData, to be used in initial-value problems Problem(model, initial::InitialData, param).\n\n\n\nSolitaryWhitham(c; ϵ=1,μ=1,N=2^12,kwargs)\n\nBuild the initial data with velocity c, dimensionless parameters ϵ and μ, and number of collocation points N, and kwargs the other (optional) keyword arguments as above.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.SolitaryWaveWhitham-Tuple{NamedTuple}","page":"Index","title":"WaterWaves1D.SolitaryWaveWhitham","text":"SolitaryWaveWhitham(param; kwargs)\n\nCompute the Whitham solitary wave with prescribed velocity.\n\nArgument\n\nparam :: NamedTuple: parameters of the problem containing velocity c and dimensionless parameters ϵ and μ, and mesh size L and number of collocation points N;\n\nKeywords (optional)\n\nguess :: Vector{Real}: initial guess for the surface deformation (if not provided, the exact formula for KdV is used);\nx₀ :: Real: center of solitary wave (if guess is not provided);\niterative :: Bool: inverts Jacobian through GMRES if true, LU decomposition if false;\nverbose :: Bool: prints numerical errors at each step if true;\nmax_iter :: Int: maximum number of iterations of the Newton algorithm;\ntol :: Real: general tolerance (default is 1e-10);\nktol :: Real: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ngtol :: Real: relative tolerance of the GMRES algorithm (default is 1e-10);\ndealias :: Int: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nq :: Real: Newton algorithm modified with\n\nu_{n+1}=q*u_{n+1}+(1-q)*u_n (default is 1);\n\nα :: Real: adds α times spectral projection onto the Kernel to the Jacobian;\nKdV :: Bool: if true computes the KdV (instead of Whitham) solitary wave.\n\nReturn values\n\n(u,mesh) with\n\nu :: Vector{Float64}: the solution;\nmesh :: Mesh: mesh collocation points.\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.Random","page":"Index","title":"WaterWaves1D.Random","text":"Random(param;args)\n\nRandomly generated initial data, based on provided (optional arguments) :\n\nL is the typical wavelength (default is L=1),\ns is the (real) Sobolev index regularity (default is s=∞),\nλ is the length of spatial localization (default is λ=∞, no localization),\na is the couple of amplitudes of the surface deformation, and velocity (default is a=(1,1)).\n\nReturn an initial data init::InitialData,  to be used in initial-value problems Problem(model, init, param), with init.η and init.v two samples of random(x;L,s,λ), where x is the set of collocation points generated by Mesh(param).\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.random-Tuple{Any}","page":"Index","title":"WaterWaves1D.random","text":"random(x;args)\n\nRandomly generate a vector of size x, based on provided (optional arguments) :\n\nL is the typical wavelength (default is L=1),\ns is the (real) Sobolev index regularity (default is s=∞, smooth data),\nλ is the length of spatial localization (default is λ=∞, no localization),\na is the amplitude of the returned vector (default is a=1).\n\nThe vector is generated through randomly chosen Fourier coefficients, multiplied with weigth w=10^(-|k|L/(2π)) if s=∞, or w=1/(1+9(|k|L/(2π))^(s+1/2)) otherwise. If λ≠∞, the function in spatial variables is multiplied by exp(-|x/λ|^2), and in any case normalized to have maximum absolute value 1.\n\n\n\n\n\n","category":"method"},{"location":"#Models","page":"Index","title":"Models","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Pages   = [ \"/#models\" ]","category":"page"},{"location":"","page":"Index","title":"Index","text":"Modules = [WaterWaves1D]\nFilter = t -> typeof(t) === DataType && t <: AbstractModel","category":"page"},{"location":"#WaterWaves1D.AbstractModel","page":"Index","title":"WaterWaves1D.AbstractModel","text":"Abstract type whose subtypes are the models from which initial-value problems can be built, through Problem( model :: AbstractModel, initial :: InitialData, param :: NamedTuple )\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.Airy","page":"Index","title":"WaterWaves1D.Airy","text":"Airy(param;label)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the linear (Airy) water waves equations.\n\nArguments\n\nparam is of type NamedTuple and must contain\n\nthe shallowness parameter μ (set the infinite-layer case if μ=Inf);\noptionally, ν the shallow/deep water scaling factor. By default, ν=1 if μ≦1 and ν=1/√μ otherwise.\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param)\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function Airy.f! to be called in explicit time-integration solvers;\na function Airy.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function Airy.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is a velocity variable which is not the derivative of the trace of the velocity potential (if not null).\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.AkersNicholls","page":"Index","title":"WaterWaves1D.AkersNicholls","text":"AkersNicholls(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the quadratic deep-water model proposed by Akers and Nicholls and Cheng, Granero-Belinchón, Shkoller and Milewski\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\noptionally, ν the shallow/deep water scaling factor. By default, ν=1 if μ≦1 and ν=1/√μ otherwise. Set the infinite-layer case if ν=0, or μ=Inf.\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param)\n\nOptional keyword arguments\n\nIL: Set the infinite-layer case if IL=true (or μ=Inf, or ν=0), in which case ϵ is the steepness parameter. Default is false.\ndealias: dealiasing with 1/3 Orlicz rule if true or no dealiasing if false (by default);\nlabel: a label for future references (default is \"deep quadratic\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function AkersNicholls.f! to be called in explicit time-integration solvers;\na function AkersNicholls.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function AkersNicholls.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is given by ∂t η = - ∂x v.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.AkersNicholls_fast","page":"Index","title":"WaterWaves1D.AkersNicholls_fast","text":"AkersNicholls_fast(param;dealias,label)\n\nSame as AkersNicholls, but faster.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.Boussinesq","page":"Index","title":"WaterWaves1D.Boussinesq","text":"Boussinesq(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for abcd-Boussinesq models (with b=d and c=0). See Bona, Chen, and Saut\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param).\n\nOptional keyword arguments\n\ntwo parameters a (default is -1/3) and b (default is +1/3) which determine the model solved. You need a+2*b=1/3 for validity as a long wave model (without surface tension).\nktol: tolerance of the low-pass Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"Boussinesq\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function Boussinesq.f! to be called in explicit time-integration solvers;\na function Boussinesq.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function Boussinesq.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is the derivative of the trace of the velocity potential.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.IsobeKakinuma","page":"Index","title":"WaterWaves1D.IsobeKakinuma","text":"IsobeKakinuma(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the Isobe-Kakinuma model proposed by Isobe.\n\nArgument\n\nparam is of type NamedTuple (or a collection NamedTuples) of and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param).\n\nOptional keyword arguments\n\niterative: solve the elliptic problem through GMRES if true, LU decomposition if false (default is true);\nprecond: use a (left) preconditioner for GMRES if true (default), choose precond as the preconditioner if provided;\ngtol: relative tolerance of the GMRES algorithm (default is 1e-14);\nrestart: the corresponding option of the GMRES algorithm (default is 100);\nmaxiter: the corresponding option of GMRES (default is nothing);\nktol: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"Isobe-Kakinuma\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function IsobeKakinuma.f! to be called in explicit time-integration solvers;\na function IsobeKakinuma.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function IsobeKakinuma.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is the derivative of the trace of the velocity potential;\nadditionally, a handy function IsobeKakinuma.mapfrofull which from data matrix returns the Tuple of real vectors (η,v,Φ), where\nΦ is the Vector of the basis functions ϕi (i∈{0,...,N}).\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.Matsuno","page":"Index","title":"WaterWaves1D.Matsuno","text":"Matsuno(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the quadratic deep-water model proposed by Matsuno.\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\noptionally, ν the shallow/deep water scaling factor. By default, ν=1 if μ≦1 and ν=1/√μ otherwise. Set the infinite-layer case if ν=0, or μ=Inf.\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param)\n\nOptional keyword arguments\n\nIL: Set the infinite-layer case if IL=true (or μ=Inf, or ν=0), in which case ϵ is the steepness parameter. Default is false.\ndealias: dealiasing with 1/3 Orlicz rule if true or no dealiasing if false (by default);\nlabel: a label for future references (default is \"Matsuno\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function DeepQuadratic.f! to be called in explicit time-integration solvers;\na function DeepQuadratic.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function DeepQuadratic.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is a velocity variable which is not the derivative of the trace of the velocity potential (if not null).\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.Matsuno_fast","page":"Index","title":"WaterWaves1D.Matsuno_fast","text":"Matsuno_fast(param;dealias,label)\n\nSame as Matsuno, but faster.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.NonHydrostatic","page":"Index","title":"WaterWaves1D.NonHydrostatic","text":"NonHydrostatic(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the \"Non-hydrostatic\" model proposed by Bristeau, Mangeney, Sainte-Marie and Seguin\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param).\n\nOptional keyword arguments\n\niterative: solve the elliptic problem through GMRES if true, LU decomposition if false (default is true);\nprecond: use a (left) preconditioner for GMRES if true (default), choose precond as the preconditioner if provided;\ngtol: relative tolerance of the GMRES algorithm (default is 1e-14);\nrestart: the corresponding option of the GMRES algorithm (default is 100);\nmaxiter: the corresponding option of GMRES (default is nothing);\nktol: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"non-hydrostatic\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function NonHydrostatic.f! to be called in explicit time-integration solvers;\na function NonHydrostatic.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function NonHydrostatic.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is the derivative of the trace of the velocity potential;\nadditionally, a handy function NonHydrostatic.mapfrofull which from data matrix returns the Tuple of real vectors (η,v,u), where\nu corresponds to the layer-averaged velocity.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.SaintVenant","page":"Index","title":"WaterWaves1D.SaintVenant","text":"SaintVenant(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for Saint-Venant (or shallow water) model.\n\nArgument\n\nparam is of type NamedTuple and must contain\n\nthe dimensionless parameter ϵ (nonlinearity);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param).\n\nOptional keyword arguments\n\nktol: tolerance of the low-pass Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"Saint-Venant\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function SaintVenant.f! to be called in explicit time-integration solvers;\na function SaintVenant.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function SaintVenant.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is the derivative of the trace of the velocity potential.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.SerreGreenNaghdi","page":"Index","title":"WaterWaves1D.SerreGreenNaghdi","text":"SerreGreenNaghdi(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the Serre-Green-Naghdi model (Serre, Su and Gardner, Green and Naghdi).\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param).\n\nOptional keyword arguments\n\niterative: solve the elliptic problem through GMRES if true, LU decomposition if false (default is true);\nprecond: use a (left) preconditioner for GMRES if true (default), choose precond as the preconditioner if provided;\ngtol: relative tolerance of the GMRES algorithm (default is 1e-14);\nrestart: the corresponding option of the GMRES algorithm (default is 100);\nmaxiter: the corresponding option of GMRES (default is nothing);\nktol: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"Green-Naghdi\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function SerreGreenNaghdi.f! to be called in explicit time-integration solvers;\na function SerreGreenNaghdi.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function SerreGreenNaghdi.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is the derivative of the trace of the velocity potential;\nadditionally, a handy function SerreGreenNaghdi.mapfrofull which from data matrix returns the Tuple of real vectors (η,v,u), where\nu corresponds to the layer-averaged velocity.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.SquareRootDepth","page":"Index","title":"WaterWaves1D.SquareRootDepth","text":"SquareRootDepth(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the \"√D\" model proposed by Cotter, Holm and Percival\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param).\n\nOptional keyword arguments\n\niterative: solve the elliptic problem through GMRES if true, LU decomposition if false (default is true);\nprecond: use a (left) preconditioner for GMRES if true (default), choose precond as the preconditioner if provided;\ngtol: relative tolerance of the GMRES algorithm (default is 1e-14);\nrestart: the corresponding option of the GMRES algorithm (default is 100);\nmaxiter: the corresponding option of GMRES (default is nothing);\nktol: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"square-root depth\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function SquareRootDepth.f! to be called in explicit time-integration solvers;\na function SquareRootDepth.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function SquareRootDepth.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is the derivative of the trace of the velocity potential;\nadditionally, a handy function SquareRootDepth.mapfrofull which from data matrix returns the Tuple of real vectors (η,v,u), where\nu corresponds to the layer-averaged velocity.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.WWn","page":"Index","title":"WaterWaves1D.WWn","text":"WWn(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the water waves expansion proposed by Dommermuth and Yue, West et al., Craig and Sulem (see also the account by Choi) with the \"rectification\" method proposed by Duchêne and Melinand.\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\noptionally, ν the shallow/deep water scaling factor. By default, ν=1 if μ≦1 and ν=1/√μ otherwise. Set the infinite-layer case if ν=0, or μ=Inf.\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param)\n\nOptional keyword arguments\n\nIL: Set the infinite-layer case if IL=true (or μ=Inf, or ν=0), in which case ϵ is the steepness parameter. Default is false.\nn :: Int: the order of the expansion; linear system if 1, quadratic if 2, cubic if 3, quartic if 4 (default and other values yield 2);\nδ and m: parameters of the rectifier operator, set as k->min(1,|δ*k|^m) or k->min(1,|δ*k|^m[1]*exp(1-|δ*k|^m[2])) if m is a couple\n\n(by default is δ=0, i.e. no regularization and m=-1. Notice m=-Inf and δ>0 yields a cut-off filter);\n\nktol: tolerance of the low-pass Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"WWn\" with n the order of the expansion);\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function WWn.f! to be called in explicit time-integration solvers (also WWn.f1! and WWn.f2! for the symplectic Euler solver);\na function WWn.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function WWn.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is the derivative of the trace of the velocity potential.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.WaterWaves","page":"Index","title":"WaterWaves1D.WaterWaves","text":"WaterWaves(param; kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the water waves system (via conformal mapping, see Zakharov, Dyachenko and Vasilyev).\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\noptionally, ν the shallow/deep water scaling factor. By default, ν=1 if μ≦1 and ν=1/√μ otherwise. Set the infinite-layer case if ν=0, or μ=Inf.\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param).\n\nOptional keyword arguments\n\nIL: Set the infinite-layer case if IL=true, in which case ϵ is the steepness parameter. Default is false.\nmethod ∈ {1,2,3}: method used to initialize the conformal mapping, as a fix-point problem F(u)=u\nif method == 1, use standard contraction fix-point iteration;\nif method == 2, use Newton algorithm with GMRES iterative solver to invert the Jacobian;\nif method == 3, use Newton algorithm with direct solver to invert the Jacobian;\ntol: (relative) tolerance of the fix-point algorithm (default is 1e-16);\nmaxiter: the maximal number of iteration in the fix-point algorithm (default is 100);\nktol: tolerance of the low-pass Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"water waves\");\nverbose: prints information if true (default is true).\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function WaterWaves.f! to be called in the explicit time-integration solver (also WaterWaves.f1! and WaterWaves.f2! for the symplectic Euler solver);\na function WaterWaves.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function WaterWaves.mapfro which from such data matrix returns the Tuple of real vectors (x,η,v), where\nx is a vector of collocation points (non-regularly spaced);\nη is the surface deformation at points x;\nv is the derivative of the trace of the velocity potential at points x.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.WhithamBoussinesq","page":"Index","title":"WaterWaves1D.WhithamBoussinesq","text":"WhithamBoussinesq(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for a Boussinesq-type model with full-dispersion property.\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param)\n\nOptional keyword arguments\n\nBoussinesq: if true (default is false), compute the standard Boussinesq system instead (see Boussinesq(param;kwargs));\na parameter α which determines the model solved:\nIf α = 1 (default), then the model has been introduced in Dinvay, Dutykh and Kalisch;\nIf α = 1/2, then the model is a quasilinear version;\nIf α < 1/2, then expect instabilities stemming from ill-posedness of the model.\nktol: tolerance of the low-pass Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"Whitham-Boussinesq\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function WhithamBoussinesq.f! to be called in explicit time-integration solvers;\na function WhithamBoussinesq.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed.\na function WhithamBoussinesq.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is the derivative of the trace of the velocity potential.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.WhithamGreenNaghdi","page":"Index","title":"WaterWaves1D.WhithamGreenNaghdi","text":"WhithamGreenNaghdi(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the fully dispersive Green-Naghdi model proposed by Duchêne, Israwi and Talhouk.\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param).\n\nOptional keyword arguments\n\nSGN: if true (default is false), compute the Serre-Green-Naghdi (SGN) instead of Whitham-Green-Naghdi (WGN) system (see SerreGreenNaghdi(param;kwargs));\niterative: solve the elliptic problem through GMRES if true, LU decomposition if false (default is true);\nprecond: use a (left) preconditioner for GMRES if true (default), choose precond as the preconditioner if provided;\ngtol: relative tolerance of the GMRES algorithm (default is 1e-14);\nrestart: the corresponding option of the GMRES algorithm (default is 100);\nmaxiter: the corresponding option of GMRES (default is nothing);\nktol: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"Whitham-Green-Naghdi\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function WhithamGreenNaghdi.f! to be called in explicit time-integration solvers;\na function WhithamGreenNaghdi.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function WhithamGreenNaghdi.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is the derivative of the trace of the velocity potential;\nadditionally, a handy function WhithamGreenNaghdi.mapfrofull which from data matrix returns the Tuple of real vectors (η,v,u), where\nu corresponds to the layer-averaged velocity.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.modifiedMatsuno","page":"Index","title":"WaterWaves1D.modifiedMatsuno","text":"modifiedMatsuno(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the modified Matsuno model\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\noptionally, ν the shallow/deep water scaling factor. By default, ν=1 if μ≦1 and ν=1/√μ otherwise. Set the infinite-layer case if ν=0, or μ=Inf.\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param)\n\nOptional keyword arguments\n\nIL: Set the infinite-layer case if IL=true (or μ=Inf, or ν=0), in which case ϵ is the steepness parameter. Default is false.\nktol: tolerance of the low-pass Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"modified Matsuno\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function modifiedMatsuno.f! to be called in explicit time-integration solvers;\na function modifiedMatsuno.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function modifiedMatsuno.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is the derivative of the trace of the velocity potential.\n\n\n\n\n\n","category":"type"},{"location":"#Solvers","page":"Index","title":"Solvers","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Pages   = [ \"index#solvers.md\" ]","category":"page"},{"location":"","page":"Index","title":"Index","text":"Modules = [WaterWaves1D]\nFilter = t -> typeof(t) === DataType && t <: TimeSolver","category":"page"},{"location":"#WaterWaves1D.Euler","page":"Index","title":"WaterWaves1D.Euler","text":"Euler(arguments;realdata)\n\nExplicit Euler solver.\n\nConstruct an object of type TimeSolver to be used in Problem(model, initial, param; solver::TimeSolver)\n\nArguments can be either\n\nan object of type AbstractModel;\nan Array of size (N,m) where N is the number of collocation points and m the number of data (equations solved);\na Tuple (N,m) as above;\nan integer N and an integer m as above (the latter is optional, by default m=2).\na NamedTuple containing a key N and an integer m (the latter is optional, by default m=2).\n\nThe keyword argument realdata is optional, and determines whether pre-allocated vectors are real- or complex-valued. By default, they are either determined by the model or the type of the array in case 0. and 1., complex-valued otherwise.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.EulerSymp","page":"Index","title":"WaterWaves1D.EulerSymp","text":"EulerSymp(arguments;Niter,implicit,realdata)\n\nSymplectic Euler solver. The implicit Euler method is first used on one equation, then the explicit Euler method is used on the second one. The implicit equation is solved via Neumann iteration\n\nConstruct an object of type TimeSolver to be used in Problem(model, initial, param; solver::TimeSolver)\n\nArguments can be either\n\nan object of type AbstractModel;\nan Array of size (N,2) where N is the number of collocation points;\nan integer N being the number of collocation points;\na NamedTuple containing a key N.\n\nThe keyword argument Niter (optional, defaut value = 10) determines the number of steps in the Neumann iteration solver of the implicit step. The keyword argument implicit (optional, defaut value = 1) determines which equation is implicit (must be 1 or 2). The keyword argument realdata is optional, and determines whether pre-allocated vectors are real- or complex-valued. By default, they are either determined by the model or the type of the array in case 0. and 1., complex-valued otherwise.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.Euler_naive","page":"Index","title":"WaterWaves1D.Euler_naive","text":"Euler_naive()\n\nRunge-Kutta fourth order solver.\n\nA naive version of Euler, without argument since no pre-allocation is performed.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.RK4","page":"Index","title":"WaterWaves1D.RK4","text":"RK4(arguments;realdata)\n\nExplicit Runge-Kutta fourth order solver.\n\nConstruct an object of type TimeSolver to be used in Problem(model, initial, param; solver::TimeSolver)\n\nArguments can be either\n\nan object of type AbstractModel;\nan Array of size (N,m) where N is the number of collocation points and m the number of data (equations solved);\na Tuple (N,m) as above;\nan integer N and an integer m as above (the latter is optional, by default m=2).\na NamedTuple containing a key N and an integer m (the latter is optional, by default m=2).\n\nThe keyword argument realdata is optional, and determines whether pre-allocated vectors are real- or complex-valued. By default, they are either determined by the model in case 1., complex-valued otherwise.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.RK4_naive","page":"Index","title":"WaterWaves1D.RK4_naive","text":"RK4_naive()\n\nRunge-Kutta fourth order solver.\n\nA naive version of RK4, without argument since no pre-allocation is performed.\n\n\n\n\n\n","category":"type"},{"location":"#Tools","page":"Index","title":"Tools","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Modules = [WaterWaves1D]\nPages   = [\n\"init.jl\",\n\"tools.jl\",\n\"mesh.jl\",\n\"problem.jl\",\n\"data.jl\",\n\"times.jl\"]","category":"page"},{"location":"#WaterWaves1D.Init","page":"Index","title":"WaterWaves1D.Init","text":"Init(data ; fast, label)\n\nGenerate an initial data to be used in the function Problem.\n\ndata should contain either\n\na function η and a function v (in this order)\na Namedtuple with a function η and a function v\na mesh and two vectors representing η(mesh.x) and v(mesh.x) (in this order)\na mesh and a Namedtuple with a vector η and a vector v as above\nan array of collocation points and two vectors representing η(x) and v(x) (in this order)\na mesh and a Namedtuple with a vector η and a vector v as above\n\nIn the last four cases, an optional keyword argument fast can be set to true, (default is false), in which case the algorithm is faster and uses less allocations, but is less precise.\n\nIn the last two cases, the collocation points must be regularly spaced, otherwise an ErrorException is raised.\n\nIf the keyword label::String (used to display information to the output stream) is not provided, then it is set to the \"user-defined\".\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.interpolate-Tuple{Mesh, Any, Any}","page":"Index","title":"WaterWaves1D.interpolate","text":"interpolate(mesh,vector,x;fast)\n\nInterpolate a vector vector defined on a uniform collocation grid defined by mesh, on collocation points given by x.\n\nIf the collocation points x are regularly spaced and the optional keyword argument fast is set to true (default is false), then the algorithm is faster and uses less allocations, but is less precise.\n\nReturns the vector of values on collocation points.\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.interpolate-Tuple{Mesh, Any}","page":"Index","title":"WaterWaves1D.interpolate","text":"interpolate(mesh,vector;n=2^3)\n\nInterpolate a vector vector defined on a uniform collocation grid defined by mesh.\n\nReturns (new_mesh,new_vector) a new uniform mesh with n times as many values, and the vector of values on collocation points.\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.solution-Tuple{Problem}","page":"Index","title":"WaterWaves1D.solution","text":"solution(p::Problem;t,x,interpolation)\n\nGives the solution of a solved initial-value at a given time t.\n\nArguments\n\nArgument p is of type Problem.\nKeyword argument t is optional, the last computed time is returned by default.\nKeyword argument x is optional, if provided the solution is interpolated to the collocation vector x.\nKeyword argument interpolation is optional, if an integer is provided the solution is interpolated on as many collocation points (if true, then the default value 2^3 is chosen).\n\nReturn values\n\nProvides (η,v,x,t) where\n\nη is the surface deformation at collocation points;\nv is the tangential velocity (derivative of the trace of the velocity potential) at collocation points;\nx is the vector of collocation points;\nt the time (first computed time greater or equal to provided t).\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.Mesh","page":"Index","title":"WaterWaves1D.Mesh","text":"Mesh(args)\n\nConstructs a mesh of collocation points and associated Fourier modes.\n\nArguments\n\nCan be either\n\nxmin, xmax, and N; or\nL, N (same as above with xmin=-L and xmax=L); or\nparam :: NamedTuple, a NamedTuple containing N and L or xmin and xmax, then same as above; or\nx a vector of regularly spaced collocation points`.\n\nThe mesh as N collocation points regularly spaced between xmin (included) and xmax (excluded)\n\nReturn values\n\nm=Mesh(args) is of parametric type and offers with\n\nm.N: number of collocation points and Fourier modes;\nm.xmin: minimum of the mesh (included in the vector of collocation points);\nm.xmax: maximum of the mesh (excluded in the vector of collocation points);\nm.dx: distance between two collocation points;\nm.x: the vector of collocation points;\nm.kmin: minimum of Fourier modes (included in the vector of Fourier modes);\nm.kmax: maximum of Fourier modes (included in the vector of Fourier modes);;\nm.dk: distance between two Fourier modes;\nm.k: the vector of Fourier modes.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.Problem","page":"Index","title":"WaterWaves1D.Problem","text":"Problem( model, initial, param ; solver, label)\n\nBuild an initial-value problem which can then be solved (i.e. integrated in time) through solve!( problem )\n\nArguments\n\nmodel   :: AbstractModel,  the system of equation solved.\n\nMay be built, e.g., by WaterWaves(param);\n\ninitial :: InitialData, the initial data.\n\nMay be buit, e.g., by Init(η,v) where η is the surface deformation and v the derivative of the trace of the velocity potential at the surface;\n\nparam   :: NamedTuple, must contain values for\nN, the number of collocation points of the spatial grid\nL, the half-length of the spatial grid\nT, the final time of integration\ndt, the timestep\nadditionally, it may contain Ns the number of computed data or ns for storing data every ns computation steps (by default, every computed data is stored).\n\nOptional keyword arguments\n\nsolver :: TimeSolver, the solver for time integration (default is explicit Runge-Kutta fourth order solver).\n\nMay be built, e.g., by RK4(model) or RK4_naive().\n\nlabel   :: String is used in future references (e.g.plot_solution`).\nInformation are not printed if verbose = false (default is true).\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.solve!-Tuple{Any}","page":"Index","title":"WaterWaves1D.solve!","text":"solve!( problems; verbose=true )\n\nSolve (i.e. integrate in time) a collection of initial-value problems.\n\nThe argument problems should be a collection (list, array...) of elements of type Problem.\n\nInformation are not printed if keyword argument verbose = false (default is true).\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.solve!-Tuple{Problem}","page":"Index","title":"WaterWaves1D.solve!","text":"solve!( problem :: Problem; verbose=true )\n\nSolve (i.e. integrate in time) an initial-value problem\n\nThe argument problem should be of type Problem. It may be buit, e.g., by Problem(model, initial, param)\n\nInformation are not printed if keyword argument verbose = false (default is true).\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.Data","page":"Index","title":"WaterWaves1D.Data","text":"Data( mm :: Matrix )\n\nData structure to store the solution of an initial-value problem along time.\n\ndata=Data(m) is of parametric type and offers\n\ndata.U, a 1-element vector with a copy of the matrix m;\n(data.datalength,data.datasize)=size(m)  where datalength is the number of computed modes, and datasize the number of involved equations, typically 2.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.Times","page":"Index","title":"WaterWaves1D.Times","text":"Times(param; ns, Ns)\n\nConstructs a mesh of times, to be used in initial-value problems (see Problem).\n\nArguments\n\nparam is either\n\ndt,T with dt the timestep and T the final time of comuptation; or\na NamedTuple containing dt and T\n\nOptional keyword arguments\n\nns  : data are stored every ns computations (optional, default = 1).\nNs  : Ns data (in addition to the initial datum) are stored (optional, by default `floor( tfin/dt)).\n\nIf both Ns and ns are given, Ns overrules ns.\n\nReturn values\n\nt=Times(args) is of parametric type and offers\n\nt.Nc: number of computed times (including initial datum);\nt.Ns: number of stored times (including initial datum);\nt.ns: number of computed times between two stored times;\nt.tfin: the final time;\nt.dt: the timestep;\nt.tc : the vector of computed times;\nt.ts: the vector of stored times.\n\n\n\n\n\n","category":"type"},{"location":"#Graphics","page":"Index","title":"Graphics","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Modules = [WaterWaves1D]\nPages   = [\"figures.jl\"]","category":"page"},{"location":"#WaterWaves1D.create_animation-Tuple{Any}","page":"Index","title":"WaterWaves1D.create_animation","text":"create_animation( problems; name::String, kwargs... )\n\nCreate an animation showing the evolution of initial-value problems.\n\nArgument problems is either an element or a collection (vector, list, etc.) of elements of type Problem.\n\nThe animation is saved as name.gif if name is provided.\n\nOther keyword arguments are as follows\n\nxlims allows to specifies the x axis limits for the surface deformation. If nothing is provided (default), then the full numerical basin is represented.\nylims allows to specifies the y axis limits for the surface deformation. If nothing is provided (default), then the limits are determined from the initial data. If anything but a Tuple is provided, the axis limits evolve with the solution.\nvlims and flims are as above, but for the velocity and Fourier coefficients plots.\nNframes gives the (maximal) number of frames in the animation.\nother arguments of plot_solution!\n\nReturn anim, an animation, which can then generate (for instance) a gif through gif(anim, \"my_name.gif\", fps=15).\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.plot_difference!-Tuple{Any, Any}","page":"Index","title":"WaterWaves1D.plot_difference!","text":"plot_difference!( plt, problems ; t,x,interpolation,compression,fast,surface,velocity,fourier,label )\n\nPlots in plt the difference between solutions of initial-value problems at a given time.\n\nArgument\n\npairs is a either a collection (vector, list, etc.) of elements of type Problem, or of pairs of such elements. If pairs are provided, then solutions of such problems are compared. If a collection of problems are provided, then all possible pairs are compared.\n\nKeyword arguments (all optional)\n\nt is the time. If not provided, then the last computed time is plotted.\nif a vector x is provided and if possible, the solution is interpolated to the collocation points x.\nif interpolation is provided as an integer, the solution is interpolated on as many collocation points (if true, then the value 2^3 is chosen, default is false).\nif fast = false (default is false), then the second problem is interpolated to the collocation points of the first problem.\nif compression is provided as an integer m, only one in m points are plotted (if true, then the value 2^3 is chosen, default is false).\nsurface, velocity and fourier (booleans) determine respectively whether surface deformation, η, tangential velocity, v, and the Fourier coefficients of η (in log-scale) are plotted.\nlabel defines the label(s) if provided (otherwise labels are inferred from the problems).\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.plot_difference-Tuple{Any}","page":"Index","title":"WaterWaves1D.plot_difference","text":"plot_difference( pairs; t,x, interpolation,compression, surface,velocity,fourier, label )\n\nSame as plot_difference! but generates and returns the plot.\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.plot_solution!-Tuple{Any, Any}","page":"Index","title":"WaterWaves1D.plot_solution!","text":"plot_solution!( plt; problems; t,x,interpolation,compression,surface,velocity,fourier,label )\n\nPlots in plt the solution of initial-value problems at a given time.\n\nArgument\n\nproblems is either an element or a collection (vector, list, etc.) of elements of type Problem.\n\nKeyword arguments (all optional)\n\nt is the time. If not provided, then the last computed time is plotted.\nif a vector x is provided and if possible, the solution is interpolated to the collocation points x.\nif interpolation is provided as an integer, the solution is interpolated on as many collocation points (if true, then the value 2^3 is chosen, default is false).\nif compression is provided as an integer m, only one in m points are plotted (if true, then the value 2^3 is chosen, default is false).\nsurface, velocity and fourier (booleans) determine respectively whether surface deformation, η, tangential velocity, v, and the Fourier coefficients of η (in log-scale) are plotted.\nlabel defines the label(s) if provided (otherwise labels are inferred from the problems)\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.plot_solution-Tuple{Any}","page":"Index","title":"WaterWaves1D.plot_solution","text":"plot_solution( problems; t,x, interpolation,compression, surface,velocity,fourier, label )\n\nSame as plot_solution! but generates and returns the plot.\n\n\n\n\n\n","category":"method"},{"location":"example/#Example","page":"Example","title":"Example","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"In this example we shall observe the disintegration of a heap of water using the water-waves system as well as a second-order small-steepness model.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"More advanced examples can be found in the package's examples and notebooks section.","category":"page"},{"location":"example/#Set-up-the-initial-value-problem","page":"Example","title":"Set up the initial-value problem","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"First we define parameters of our problem.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using Plots\nusing WaterWaves1D\n\nparam = (\n    # Physical parameters. Variables are non-dimensionalized as in Lannes, The water waves problem, isbn:978-0-8218-9470-5\n    μ  = 1,     # shallow-water dimensionless parameter\n    ϵ  = 1/4,   # nonlinearity dimensionless parameter\n    # Numerical parameters\n    N  = 2^10,  # number of collocation points\n    L  = 10,    # half-length of the numerical tank (-L,L)\n    T  = 5,     # final time of computation\n    dt = 0.01,  # timestep\n                );","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Now we define initial data (the \"heap of water\"). The function Init may take either functions, or vectors (values at collocation points) as arguments.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"z(x) = exp.(-abs.(x).^4); # surface deformation\nv(x) = 0*exp.(-x.^2);     # zero initial velocity\ninit = Init(z,v);         # generate the initial data with correct type","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Then we build the different models to compare (see WaterWaves and WWn).","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"WW_model=WaterWaves(param) # The water waves system\nWW2_model=WWn(param;n=2,dealias=1,δ=1/10) # The quadratic model (WW2)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Finally we set up initial-value problems. Optionally, one may specify a time solver to Problem, by default the standard explicit fourth order Runge Kutta method is used.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"WW_problem=Problem(WW_model, init, param) ;\nWW2_problem=Problem(WW2_model, init, param) ;","category":"page"},{"location":"example/#Solve-the-initial-value-problem","page":"Example","title":"Solve the initial-value problem","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Solving the initial-value problems is as easy as solve!.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"solve!([WW_problem WW2_problem];verbose=false);","category":"page"},{"location":"example/#Generate-graphics","page":"Example","title":"Generate graphics","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Plot solutions at final time (plot_solution has many options).","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"plot_solution([WW_problem WW2_problem];fourier=false)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Generate an animation (plot_solution has many options).","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"anim = create_animation([WW_problem WW2_problem];fourier=false,ylims=(-0.5,1))\ngif(anim, \"assets/example.gif\", fps=15); nothing # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"(Image: )","category":"page"}]
}
