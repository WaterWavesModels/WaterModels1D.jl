var documenterSearchIndex = {"docs":
[{"location":"howto/#How-to-guides","page":"How-to...","title":"How-to guides","text":"","category":"section"},{"location":"howto/#Add-your-model","page":"How-to...","title":"Add your model","text":"","category":"section"},{"location":"howto/#Add-your-initial-data","page":"How-to...","title":"Add your initial data","text":"","category":"section"},{"location":"howto/#Add-your-solver","page":"How-to...","title":"Add your solver","text":"","category":"section"},{"location":"contents/#Contents","page":"Contents","title":"Contents","text":"","category":"section"},{"location":"contents/","page":"Contents","title":"Contents","text":"","category":"page"},{"location":"contents/#Index","page":"Contents","title":"Index","text":"","category":"section"},{"location":"contents/","page":"Contents","title":"Contents","text":"","category":"page"},{"location":"quickstart/#Quickstart","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"WaterWaves1D provides a framework to study and compare several models for the propagation of unidimensional surface gravity waves (a.k.a. \"water waves\").","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"In the following examples, we","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"build a solitary wave profile for a fully dispersive \"Whitham-Boussinesq\" system;\ncheck the numerical accuracy of the produced solitary wave and time integration solver;\nintegrate numerically the complete water waves system with the solitary wave profile as initial data.","category":"page"},{"location":"quickstart/#Build-the-solitary-wave-profile","page":"Quickstart","title":"Build the solitary wave profile","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"using WaterWaves1D\n\nparam = ( ϵ  = 1/2,\n          N  = 2^12,\n          L  = 10.,\n          T  = 5.,\n          dt = 0.001,\n          θ = 2.5 )\n\ninit    = BellCurve(param)\nmodel   = Matsuno(param)\nproblem = Problem(model, init, param)\n\nsolve!( problem )\n\nplot_solution(problem)\n","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"using WaterWaves1D","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"\nplot_solution(problem)","category":"page"},{"location":"quickstart/#Solve-the-Whitham-Boussinesq-system","page":"Quickstart","title":"Solve the Whitham-Boussinesq system","text":"","category":"section"},{"location":"quickstart/#Solve-the-water-waves-systen","page":"Quickstart","title":"Solve the water waves systen","text":"","category":"section"},{"location":"basics/#Code-basics","page":"Code basics","title":"Code basics","text":"","category":"section"},{"location":"basics/#Abstract-types","page":"Code basics","title":"Abstract types","text":"","category":"section"},{"location":"basics/","page":"Code basics","title":"Code basics","text":"TimeSolver (RK4, Euler, etc),\nAbstractModel (Cheng, Matsuno, etc),\nInitialData (Bump, SolitaryWave, etc)","category":"page"},{"location":"basics/","page":"Code basics","title":"Code basics","text":"Instances are created from Parameters type.","category":"page"},{"location":"basics/","page":"Code basics","title":"Code basics","text":"Parameters","category":"page"},{"location":"basics/","page":"Code basics","title":"Code basics","text":"Une structure Problem  représente un problème donné que l'on va résoudre. Les données seront stockées dans data, qui est vide initialement.","category":"page"},{"location":"basics/","page":"Code basics","title":"Code basics","text":"Problem","category":"page"},{"location":"basics/#WaterWaves1D.Problem","page":"Code basics","title":"WaterWaves1D.Problem","text":"Problem( model, initial, param ; solver, label, verbose=true)\n\nBuild an initial-value problem which can then be solved (i.e. integrated in time) through solve!( problem )\n\nArguments\n\nmodel   :: AbstractModel,  the system of equation solved.\n\nMay be built, e.g., by WaterWaves(param);\n\ninitial :: InitialData, the initial data.\n\nMay be buit, e.g., by Init(η,v) where η is the surface deformation and v the derivative of the trace of the velocity potential at the surface;\n\nparam   :: NamedTuple, must contain values for\nN, the number of collocation points of the spatial grid\nL, the half-length of the spatial grid\nT, the final time of integration\ndt, the timestep\nadditionally, it may contain Ns the number of computed data or ns for storing data every ns computation steps (by default, every computed data is stored).\n\nOptional keyword arguments\n\nsolver :: TimeSolver, the solver for time integration (default is explicit Runge-Kutta fourth order solver).\n\nMay be built, e.g., by RK4(model) or RK4_naive().\n\nlabel   :: String is used in future references (e.g.plot_solution`).\nInformation are not printed if verbose = false (default is true).\n\n\n\n\n\n","category":"type"},{"location":"basics/#Initial-data","page":"Code basics","title":"Initial data","text":"","category":"section"},{"location":"basics/","page":"Code basics","title":"Code basics","text":"Bump","category":"page"},{"location":"basics/#models","page":"Code basics","title":"models","text":"","category":"section"},{"location":"basics/","page":"Code basics","title":"Code basics","text":"Cheng","category":"page"},{"location":"basics/","page":"Code basics","title":"Code basics","text":"Matsuno","category":"page"},{"location":"basics/#WaterWaves1D.Matsuno","page":"Code basics","title":"WaterWaves1D.Matsuno","text":"Matsuno(param;dealias,label,verbose)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the quadratic deep-water model proposed by Matsuno.\n\nArguments\n\nparam is of type NamedTuple and must contain\n\nthe dimensionless parameters ϵ (nonlinearity);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param).\n\nOptional keyword arguments\n\ndealias: dealiasing with 1/3 Orlicz rule if true or no dealiasing if false (by default);\nlabel: a label for future references (default is \"Matsuno\");\nverbose: prints information if true (default is true).\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function DeepQuadratic.f! to be called in explicit time-integration solvers;\na function DeepQuadratic.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function DeepQuadratic.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is a velocity variable which is not the derivative of the trace of the velocity potential (if not null).\n\n\n\n\n\n","category":"type"},{"location":"basics/","page":"Code basics","title":"Code basics","text":"solve!(::Problem)","category":"page"},{"location":"basics/#WaterWaves1D.solve!-Tuple{Problem}","page":"Code basics","title":"WaterWaves1D.solve!","text":"solve!( problem :: Problem; verbose=true )\n\nSolve (i.e. integrate in time) an initial-value problem\n\nThe argument problem should be of type Problem. It may be buit, e.g., by Problem(model, initial, param)\n\nInformation are not printed if keyword argument verbose = false (default is true).\n\n\n\n\n\n","category":"method"},{"location":"basics/#Main-program","page":"Code basics","title":"Main program","text":"","category":"section"},{"location":"basics/","page":"Code basics","title":"Code basics","text":"epsilon = 1/2\nN       = 2^12\nL       = 10\nT       = 5\ndt      = 0.001\n\nparam = Parameters(epsilon,N,L,T,dt)\n\nproblems = [Problem(Cheng,Bump,param,RK4),Problem(Matsuno,Bump,param,RK4)]","category":"page"},{"location":"basics/","page":"Code basics","title":"Code basics","text":"Cheng est le modèle utilisé. Il prend en valeur Bump, param et définit 3 fonction:","category":"page"},{"location":"basics/","page":"Code basics","title":"Code basics","text":"init qui construit une donnée initiale à partir de Bump : Uinit=init(Bump,param)\nFwave utilisée pour résoudre dt U= Fwave(U) (avec donnée initiale Uinit)\nbuild qui reconstruit la donnée finale (c'est l'application inverse de init). Ufin=final(U,param)","category":"page"},{"location":"basics/","page":"Code basics","title":"Code basics","text":"init(::Cheng)\ninit(::Matsuno)","category":"page"},{"location":"basics/","page":"Code basics","title":"Code basics","text":"build(::Cheng)\nbuild(::Matsuno)","category":"page"},{"location":"basics/","page":"Code basics","title":"Code basics","text":"simuls = [(Cheng,Bump,param1,RK4),(Cheng,Bump,param2,RK4)]","category":"page"},{"location":"basics/#RK4-solver","page":"Code basics","title":"RK4 solver","text":"","category":"section"},{"location":"basics/","page":"Code basics","title":"Code basics","text":"RK4","category":"page"},{"location":"basics/#WaterWaves1D.RK4","page":"Code basics","title":"WaterWaves1D.RK4","text":"RK4(arguments;realdata)\n\nExplicit Runge-Kutta fourth order solver.\n\nConstruct an object of type TimeSolver to be used in Problem(model, initial, param; solver::TimeSolver)\n\nArguments can be either\n\nan object of type AbstractModel;\nan Array of size (N,m) where N is the number of collocation points and m the number of data (equations solved);\na Tuple (N,m) as above;\nan integer N and an integer m as above (the latter is optional, by default m=2).\na NamedTuple containing a key N and an integer m (the latter is optional, by default m=2).\n\nThe keyword argument realdata is optional, and determines whether pre-allocated vectors are real- or complex-valued. By default, they are either determined by the model in case 1., complex-valued otherwise.\n\n\n\n\n\n","category":"type"},{"location":"basics/","page":"Code basics","title":"Code basics","text":"for p in problems\n    solve!(p)\nend","category":"page"},{"location":"#WaterWaves1D.jl","page":"Documentation","title":"WaterWaves1D.jl","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"Modules = [WaterWaves1D]\nOrder   = [:type, :function]","category":"page"},{"location":"#WaterWaves1D.Boussinesq","page":"Documentation","title":"WaterWaves1D.Boussinesq","text":"Boussinesq(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for abcd-Boussinesq models (with b=d and c=0). See Bona, Chen, and Saut\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param).\n\nOptional keyword arguments\n\ntwo parameters a (default is -1/3) and b (default is +1/3) which determine the model solved. You need a+2*b=1/3 for validity as a long wave model (without surface tension).\nktol: tolerance of the low-pass Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"Boussinesq\");\nverbose: prints information if true (default is true).\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function Boussinesq.f! to be called in explicit time-integration solvers;\na function Boussinesq.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function Boussinesq.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is the derivative of the trace of the velocity potential.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.Data","page":"Documentation","title":"WaterWaves1D.Data","text":"Data( mm :: Matrix )\n\nData structure to store the solution of an initial-value problem along time.\n\ndata=Data(m) is of parametric type and offers\n\ndata.U, a 1-element vector with a copy of the matrix m;\n(data.datalength,data.datasize)=size(m)  where datalength is the number of computed modes, and datasize the number of involved equations, typically 2.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.DeepQuadratic","page":"Documentation","title":"WaterWaves1D.DeepQuadratic","text":"DeepQuadratic(param;dealias,label,verbose)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the quadratic deep-water model proposed by Akers and Milewski and Cheng, Granero-Belinchón, Shkoller and Milewski\n\nArguments\n\nparam is of type NamedTuple and must contain\n\nthe dimensionless parameters ϵ (nonlinearity);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param).\n\nOptional keyword arguments\n\ndealias: dealiasing with 1/3 Orlicz rule if true or no dealiasing if false (by default);\nlabel: a label for future references (default is \"deep quadratic\");\nverbose: prints information if true (default is true).\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function DeepQuadratic.f! to be called in explicit time-integration solvers;\na function DeepQuadratic.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function DeepQuadratic.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is given by ∂t η = - ∂x v.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.DeepQuadratic_fast","page":"Documentation","title":"WaterWaves1D.DeepQuadratic_fast","text":"DeepQuadratic_fast(param;dealias,label,verbose)\n\nSame as DeepQuadratic, but faster.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.Euler","page":"Documentation","title":"WaterWaves1D.Euler","text":"Euler(arguments;realdata)\n\nExplicit Euler solver.\n\nConstruct an object of type TimeSolver to be used in Problem(model, initial, param; solver::TimeSolver)\n\nArguments can be either\n\nan object of type AbstractModel;\nan Array of size (N,m) where N is the number of collocation points and m the number of data (equations solved);\na Tuple (N,m) as above;\nan integer N and an integer m as above (the latter is optional, by default m=2).\na NamedTuple containing a key N and an integer m (the latter is optional, by default m=2).\n\nThe keyword argument realdata is optional, and determines whether pre-allocated vectors are real- or complex-valued. By default, they are either determined by the model or the type of the array in case 0. and 1., complex-valued otherwise.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.EulerSymp","page":"Documentation","title":"WaterWaves1D.EulerSymp","text":"EulerSymp(arguments;Niter,implicit,realdata)\n\nSymplectic Euler solver. The implicit Euler method is first used on one equation, then the explicit Euler method is used on the second one. The implicit equation is solved via Neumann iteration\n\nConstruct an object of type TimeSolver to be used in Problem(model, initial, param; solver::TimeSolver)\n\nArguments can be either\n\nan object of type AbstractModel;\nan Array of size (N,2) where N is the number of collocation points;\nan integer N being the number of collocation points;\na NamedTuple containing a key N.\n\nThe keyword argument Niter (optional, defaut value = 10) determines the number of steps in the Neumann iteration solver of the implicit step. The keyword argument implicit (optional, defaut value = 1) determines which equation is implicit (must be 1 or 2). The keyword argument realdata is optional, and determines whether pre-allocated vectors are real- or complex-valued. By default, they are either determined by the model or the type of the array in case 0. and 1., complex-valued otherwise.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.Euler_naive","page":"Documentation","title":"WaterWaves1D.Euler_naive","text":"Euler_naive()\n\nRunge-Kutta fourth order solver.\n\nA naive version of Euler, without argument since no pre-allocation is performed.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.Init","page":"Documentation","title":"WaterWaves1D.Init","text":"Init(data ; fast=false)\n\nGenerate an initial data to be used in the function Problem.\n\ndata should contain either\n\na function η and a function v (in this order)\na Namedtuple with a function η and a function v\na mesh and two vectors representing η(mesh.x) and v(mesh.x) (in this order)\na mesh and a Namedtuple with a vector η and a vector v as above\nan array of collocation points and two vectors representing η(x) and v(x) (in this order)\na mesh and a Namedtuple with a vector η and a vector v as above\n\nIn the last four cases, an optional keyword argument fast can be set to true, (default is false), in which case the algorithm is faster and uses less allocations, but is less precise.\n\nIn the last two cases, the collocation points must be regularly spaced, otherwise an ErrorException is raised.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.IsobeKakinuma","page":"Documentation","title":"WaterWaves1D.IsobeKakinuma","text":"IsobeKakinuma(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the Isobe-Kakinuma model.\n\nArgument\n\nparam is of type NamedTuple (or a collection NamedTuples) of and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param).\n\nOptional keyword arguments\n\niterative: solve the elliptic problem through GMRES if true, LU decomposition if false (default is true);\nprecond: use a (left) preconditioner for GMRES if true (default), choose precond as the preconditioner if provided;\ngtol: relative tolerance of the GMRES algorithm (default is 1e-14);\nrestart: the corresponding option of the GMRES algorithm (default is 100);\nmaxiter: the corresponding option of GMRES (default is nothing);\nktol: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"Isobe-Kakinuma\");\nverbose: prints information if true (default is true).\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function IsobeKakinuma.f! to be called in explicit time-integration solvers;\na function IsobeKakinuma.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function IsobeKakinuma.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is the derivative of the trace of the velocity potential;\nadditionally, a handy function IsobeKakinuma.mapfrofull which from data matrix returns the Tuple of real vectors (η,v,Φ), where\nΦ is the Vector of the basis functions ϕi (i∈{0,...,N}).\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.Matsuno_fast","page":"Documentation","title":"WaterWaves1D.Matsuno_fast","text":"Matsuno_fast(param;dealias,label,verbose)\n\nSame as Matsuno, but faster.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.Mesh","page":"Documentation","title":"WaterWaves1D.Mesh","text":"Mesh(args)\n\nConstructs a mesh of collocation points and associated Fourier modes.\n\nArguments\n\nCan be either\n\nxmin, xmax, and N; or\nL, N (same as above with xmin=-L and xmax=L); or\nparam :: NamedTuple, a NamedTuple containing N and L or xmin and xmax, then same as above; or\nx a vector of regularly spaced collocation points`.\n\nThe mesh as N collocation points regularly spaced between xmin (included) and xmax (excluded)\n\nReturn values\n\nm=Mesh(args) is of parametric type and offers with\n\nm.N: number of collocation points and Fourier modes;\nm.xmin: minimum of the mesh (included in the vector of collocation points);\nm.xmax: maximum of the mesh (excluded in the vector of collocation points);\nm.dx: distance between two collocation points;\nm.x: the vector of collocation points;\nm.kmin: minimum of Fourier modes (included in the vector of Fourier modes);\nm.kmax: maximum of Fourier modes (included in the vector of Fourier modes);;\nm.dk: distance between two Fourier modes;\nm.k: the vector of Fourier modes.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.NonHydrostatic","page":"Documentation","title":"WaterWaves1D.NonHydrostatic","text":"NonHydrostatic(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the \"Non-hydrostatic\" model proposed by Bristeau, Mangeney, Sainte-Marie and Seguin\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param).\n\nOptional keyword arguments\n\niterative: solve the elliptic problem through GMRES if true, LU decomposition if false (default is true);\nprecond: use a (left) preconditioner for GMRES if true (default), choose precond as the preconditioner if provided;\ngtol: relative tolerance of the GMRES algorithm (default is 1e-14);\nrestart: the corresponding option of the GMRES algorithm (default is 100);\nmaxiter: the corresponding option of GMRES (default is nothing);\nktol: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"non-hydrostatic\");\nverbose: prints information if true (default is true).\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function NonHydrostatic.f! to be called in explicit time-integration solvers;\na function NonHydrostatic.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function NonHydrostatic.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is the derivative of the trace of the velocity potential;\nadditionally, a handy function NonHydrostatic.mapfrofull which from data matrix returns the Tuple of real vectors (η,v,u), where\nu corresponds to the layer-averaged velocity.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.RK4_naive","page":"Documentation","title":"WaterWaves1D.RK4_naive","text":"RK4_naive()\n\nRunge-Kutta fourth order solver.\n\nA naive version of RK4, without argument since no pre-allocation is performed.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.Random","page":"Documentation","title":"WaterWaves1D.Random","text":"Random(;args)\n\nRandomly generated initial data, based on provided (optional arguments) :\n\nL is the typical wavelength (default is L=1)\ns is the (real) Sobolev index regularity (default is s=∞)\nλ is the length of spatial localization (default is none)\n\nThe initial data (η,v) are generated through randomly chosen Fourier coefficients, multiplied with weigth w=10^(-|k|L/(2π)) if s=∞, or w=1/(1+9(|k|L/(2π))^(s+1/2)) otherwise. If λ is provided, the function in spatial variables is multiplied by exp(-|x/λ|^2), and in any case normalized to have maximum absolute value 1.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.SerreGreenNaghdi","page":"Documentation","title":"WaterWaves1D.SerreGreenNaghdi","text":"SerreGreenNaghdi(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the Serre-Green-Naghdi model\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param).\n\nOptional keyword arguments\n\niterative: solve the elliptic problem through GMRES if true, LU decomposition if false (default is true);\nprecond: use a (left) preconditioner for GMRES if true (default), choose precond as the preconditioner if provided;\ngtol: relative tolerance of the GMRES algorithm (default is 1e-14);\nrestart: the corresponding option of the GMRES algorithm (default is 100);\nmaxiter: the corresponding option of GMRES (default is nothing);\nktol: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"Green-Naghdi\");\nverbose: prints information if true (default is true).\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function SerreGreenNaghdi.f! to be called in explicit time-integration solvers;\na function SerreGreenNaghdi.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function SerreGreenNaghdi.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is the derivative of the trace of the velocity potential;\nadditionally, a handy function SerreGreenNaghdi.mapfrofull which from data matrix returns the Tuple of real vectors (η,v,u), where\nu corresponds to the layer-averaged velocity.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.SquareRootDepth","page":"Documentation","title":"WaterWaves1D.SquareRootDepth","text":"SquareRootDepth(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the \"√D\" model proposed by Cotter, Holm and Percival\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param).\n\nOptional keyword arguments\n\niterative: solve the elliptic problem through GMRES if true, LU decomposition if false (default is true);\nprecond: use a (left) preconditioner for GMRES if true (default), choose precond as the preconditioner if provided;\ngtol: relative tolerance of the GMRES algorithm (default is 1e-14);\nrestart: the corresponding option of the GMRES algorithm (default is 100);\nmaxiter: the corresponding option of GMRES (default is nothing);\nktol: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"square-root depth\");\nverbose: prints information if true (default is true).\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function SquareRootDepth.f! to be called in explicit time-integration solvers;\na function SquareRootDepth.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function SquareRootDepth.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is the derivative of the trace of the velocity potential;\nadditionally, a handy function SquareRootDepth.mapfrofull which from data matrix returns the Tuple of real vectors (η,v,u), where\nu corresponds to the layer-averaged velocity.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.Times","page":"Documentation","title":"WaterWaves1D.Times","text":"Times(param; ns, Ns)\n\nConstructs a mesh of times, to be used in initial-value problems (see Problem).\n\nArguments\n\nparam is either\n\ndt,T with dt the timestep and T the final time of comuptation; or\na NamedTuple containing dt and T\n\nOptional keyword arguments\n\nns  : data are stored every ns computations (optional, default = 1).\nNs  : Ns data (in addition to the initial datum) are stored (optional, by default `floor( tfin/dt)).\n\nIf both Ns and ns are given, Ns overrules ns.\n\nReturn values\n\nt=Times(args) is of parametric type and offers\n\nt.Nc: number of computed times (including initial datum);\nt.Ns: number of stored times (including initial datum);\nt.ns: number of computed times between two stored times;\nt.tfin: the final time;\nt.dt: the timestep;\nt.tc : the vector of computed times;\nt.ts: the vector of stored times.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.WWn","page":"Documentation","title":"WaterWaves1D.WWn","text":"WWn(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the water waves expansion proposed by Dommermuth and Yue (doi:10.1017/s002211208700288x), West et al. (doi:10.1029/jc092ic11p11803), Craig and Sulem (doi:10.1006/jcph.1993.1164) (see also the account by Choi : Fifth-order nonlinear spectral model for surface gravity waves: From pseudo-spectral to spectral formulations, RIMS Kokyuroku, 2019) with the \"rectification\" method proposed by Duchêne and Melinand.\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param)\n\nOptional keyword arguments\n\nν: shallow/deep water multiplication factor. By default, ν=1 if μ≦1 and ν=1/√μ otherwise. Set the infinite-layer case if ν=0 (or μ=Inf).\nIL: Set the infinite-layer case if IL=true (or μ=Inf, or ν=0), in which case ϵ is the steepness parameter. Default is false.\nn :: Int: the order of the expansion; linear system if 1, quadratic if 2, cubic if 3, quartic if 4 (default and other values yield 2);\nδ and m: parameters of the rectifier operator, set as k->min(1,|δ*k|^m) or k->min(1,|δ*k|^m[1]*exp(1-|δ*k|^m[2])) if m is a couple\n\n(by default is δ=0, i.e. no regularization and m=-1. Notice m=-Inf and δ>0 yields a cut-off filter);\n\nktol: tolerance of the low-pass Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"WWn\" with n the order of the expansion);\nverbose: prints information if true (default is true).\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function WWn.f! to be called in explicit time-integration solvers (also WWn.f1! and WWn.f2! for the symplectic Euler solver);\na function WWn.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function WWn.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is the derivative of the trace of the velocity potential.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.WaterWaves","page":"Documentation","title":"WaterWaves1D.WaterWaves","text":"WaterWaves(param; kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the water waves system (via conformal mapping, see Zakharov, Dyachenko and Vasilyev).\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param).\n\nOptional keyword arguments\n\nν: shallow/deep water multiplication factor (see Lannes, The water waves problem). By default, ν=1 if μ≦1 and ν=1/√μ otherwise.\nIL: Set the infinite-layer case if IL=true (or μ=Inf, or ν=0), in which case ϵ is the steepness parameter. Default is false.\nmethod ∈ {1,2,3}: method used to initialize the conformal mapping, as a fix-point problem F(u)=u\nif method == 1, use standard contraction fix-point iteration;\nif method == 2, use Newton algorithm with GMRES iterative solver to invert the Jacobian;\nif method == 3, use Newton algorithm with direct solver to invert the Jacobian;\ntol: (relative) tolerance of the fix-point algorithm (default is 1e-16);\nmaxiter: the maximal number of iteration in the fix-point algorithm (default is 100);\nktol: tolerance of the low-pass Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"water waves\");\nverbose: prints information if true (default is true).\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function WaterWaves.f! to be called in the explicit time-integration solver (also WaterWaves.f1! and WaterWaves.f2! for the symplectic Euler solver);\na function WaterWaves.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function WaterWaves.mapfro which from such data matrix returns the Tuple of real vectors (x,η,v), where\nx is a vector of collocation points (non-regularly spaced);\nη is the surface deformation at points x;\nv is the derivative of the trace of the velocity potential at points x.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.WhithamBoussinesq","page":"Documentation","title":"WaterWaves1D.WhithamBoussinesq","text":"WhithamBoussinesq(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for a Boussinesq-type model with full-dispersion property.\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param)\n\nOptional keyword arguments\n\nBoussinesq: if true (default is false), compute the standard Boussinesq system instead (see Boussinesq(param;kwargs));\na parameter α which determines the model solved:\nIf α = 1 (default), then the model has been introduced in Dinvay, Dutykh and Kalisch;\nIf α = 1/2, then the model is a quasilinear version;\nIf α < 1/2, then expect instabilities stemming from ill-posedness of the model.\nktol: tolerance of the low-pass Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"Whitham-Boussinesq\");\nverbose: prints information if true (default is true).\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function WhithamBoussinesq.f! to be called in explicit time-integration solvers;\na function WhithamBoussinesq.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed.\na function WhithamBoussinesq.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is the derivative of the trace of the velocity potential.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.WhithamGreenNaghdi","page":"Documentation","title":"WaterWaves1D.WhithamGreenNaghdi","text":"WhithamGreenNaghdi(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the fully dispersive Green-Naghdi model proposed by Duchêne, Israwi and Talhouk.\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param).\n\nOptional keyword arguments\n\nSGN: if true (default is false), compute the Serre-Green-Naghdi (SGN) instead of Whitham-Green-Naghdi (WGN) system (see SerreGreenNaghdi(param;kwargs));\niterative: solve the elliptic problem through GMRES if true, LU decomposition if false (default is true);\nprecond: use a (left) preconditioner for GMRES if true (default), choose precond as the preconditioner if provided;\ngtol: relative tolerance of the GMRES algorithm (default is 1e-14);\nrestart: the corresponding option of the GMRES algorithm (default is 100);\nmaxiter: the corresponding option of GMRES (default is nothing);\nktol: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"Whitham-Green-Naghdi\");\nverbose: prints information if true (default is true).\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function WhithamGreenNaghdi.f! to be called in explicit time-integration solvers;\na function WhithamGreenNaghdi.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function WhithamGreenNaghdi.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is the derivative of the trace of the velocity potential;\nadditionally, a handy function WhithamGreenNaghdi.mapfrofull which from data matrix returns the Tuple of real vectors (η,v,u), where\nu corresponds to the layer-averaged velocity.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.modifiedMatsuno","page":"Documentation","title":"WaterWaves1D.modifiedMatsuno","text":"modifiedMatsuno(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the modified Matsuno model\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param)\n\nOptional keyword arguments\n\nν: shallow/deep water multiplication factor. By default, ν=1 if μ≦1 and ν=1/√μ otherwise. Set the infinite-layer case if ν=0 (or μ=Inf).\nIL: Set the infinite-layer case if IL=true (or μ=Inf, or ν=0), in which case ϵ is the steepness parameter. Default is false.\nktol: tolerance of the low-pass Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"modified Matsuno\");\nverbose: prints information if true (default is true).\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function modifiedMatsuno.f! to be called in explicit time-integration solvers;\na function modifiedMatsuno.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function modifiedMatsuno.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is the derivative of the trace of the velocity potential.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.CnoidalWaveSerreGreenNaghdi-Tuple{NamedTuple}","page":"Documentation","title":"WaterWaves1D.CnoidalWaveSerreGreenNaghdi","text":"CnoidalWaveSerreGreenNaghdi(param; P)\n\nCompute the Serre-Green-Naghdi cnoidal wave with prescribed h₀<h₁<h₂. h_1 is the minimum, h_2 is the maximum of the wave. As h₀ -> h₁, the cnoidal wave converges towards the solitary wave. See for instance Gavrilyuk, Nkonga, Shyue and Truskinovsky, doi:10.1088/1361-6544/ab95ac\n\nArguments\n\nparam :: NamedTuple: parameters of the problem containing h₀<h₁<h₂ and dimensionless parameters ϵ and μ, and number of collocation points N.\nP :: Int: (keyword, optional, default = 2) the number of periods of the cnoidal wave in the constructed mesh.\n\nReturn values\n\n(η,u,v,mesh,param) with\n\nη :: Vector{Float64}: surface deformation;\nu :: Vector{Float64}: layer-averaged velocity;\nv :: Vector{Float64}: tangential velocity;\nmesh :: Mesh: mesh collocation points;\nparam :: NamedTuple: useful parameters\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.SolitaryWaveSerreGreenNaghdi-Tuple{NamedTuple}","page":"Documentation","title":"WaterWaves1D.SolitaryWaveSerreGreenNaghdi","text":"SolitaryWaveSerreGreenNaghdi(param; kwargs...)\n\nCompute the Serre-Green-Naghdi solitary wave with prescribed velocity.\n\nArguments\n\nparam :: NamedTuple: parameters of the problem containing velocity c and dimensionless parameters ϵ and μ, and mesh size L and number of collocation points N;\nx₀ :: Real: (keyword, optional, default = 0) center of solitary wave.\n\nReturn values\n\n(η,u,v) with\n\nη :: Vector{Float64}: surface deformation;\nu :: Vector{Float64}: layer-averaged velocity;\nv :: Vector{Float64}: tangential velocity;\nmesh :: Mesh: mesh collocation points.\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.SolitaryWaveWhitham-Tuple{NamedTuple}","page":"Documentation","title":"WaterWaves1D.SolitaryWaveWhitham","text":"`SolitaryWaveWhitham(param; kwargs...)`\n\nComputes the Whitham solitary wave with prescribed velocity.\n\nArgument\n\nparam :: NamedTuple: parameters of the problem containing velocity c and dimensionless parameters ϵ and μ, and mesh size L and number of collocation points N;\n\nKeywords (optional)\n\nguess :: Vector{Real}: initial guess for the surface deformation (if not provided, the exact formula for KdV is used);\nx₀ :: Real: center of solitary wave (if guess is not provided);\niterative :: Bool: inverts Jacobian through GMRES if true, LU decomposition if false;\nverbose :: Bool: prints numerical errors at each step if true;\nmax_iter :: Int: maximum number of iterations of the Newton algorithm;\ntol :: Real: general tolerance (default is 1e-10);\nktol :: Real: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ngtol :: Real: relative tolerance of the GMRES algorithm;\ndealias :: Int: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nq :: Real: Newton algorithm modified with\n\nu_{n+1}=q*u_{n+1}+(1-q)*u_n (default is 1);\n\nα :: Real: adds α times spectral projection onto the Kernel to the Jacobian;\nKdV :: Bool: if true computes the KdV (instead of Whitham) solitary wave.\n\nReturn values\n\nu :: Vector{Float64} the solution\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.SolitaryWaveWhithamBoussinesq-Tuple{NamedTuple}","page":"Documentation","title":"WaterWaves1D.SolitaryWaveWhithamBoussinesq","text":"`SolitaryWaveWhithamBoussinesq(param; kwargs...)`\n\nComputes the Whitham-Boussinesq solitary wave with prescribed velocity.\n\nArgument\n\nparam :: NamedTuple: parameters of the problem containing velocity c and dimensionless parameters ϵ and μ, and mesh size L and number of collocation points N;\n\nKeywords (optional)\n\nguess :: Vector{Real}: initial guess for the surface deformation (if not provided, the exact formula for SGN is used);\nx₀ :: Real: center of solitary wave (if guess is not provided);\nmodel :: Real: determines the model used (typically 1 or 1/2, default is 1);\niterative :: Bool: inverts Jacobian through GMRES if true, LU decomposition if false;\nverbose :: Bool: prints numerical errors at each step if true;\nmax_iter :: Int: maximum number of iterations of the Newton algorithm;\ntol :: Real: general tolerance (default is 1e-10);\nktol :: Real: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ngtol :: Real: relative tolerance of the GMRES algorithm;\ndealias :: Int: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nq :: Real: Newton algorithm modified with\n\nu_{n+1}=q*u_{n+1}+(1-q)*u_n (default is 1);\n\nα :: Real: adds α times spectral projection onto the Kernel to the Jacobian.\n\nReturn values\n\n(η,u) :: Tuple{Vector{Float64},Vector{Float64}} with\n\nη: surface deformation;\nu: velocity.\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.SolitaryWaveWhithamGreenNaghdi-Tuple{NamedTuple}","page":"Documentation","title":"WaterWaves1D.SolitaryWaveWhithamGreenNaghdi","text":"SolitaryWaveWhithamGreenNaghdi(param; kwargs...)\n\nCompute the Whitham-Green-Naghdi solitary wave with prescribed velocity.\n\nArguments\n\nparam :: NamedTuple: parameters of the problem containing velocity c and dimensionless parameters ϵ and μ, and mesh size L and number of collocation points N;\n\nKeywords (optional)\n\nguess :: Vector{Real}: initial guess for the surface deformation (if not provided, the exact formula for SGN is used);\nx₀ :: Real: center of solitary wave (if guess is not provided);\nSGN :: Bool: if true computes the Serre-Green-Naghdi (instead of Whitham-Green-Naghdi) solitary wave (consider SolitaryWaveSerreGreenNaghdi instead);\nmethod :: Int: equation used (between 1 and 4);\niterative :: Bool: inverts Jacobian through GMRES if true, LU decomposition if false (default is false);\nverbose :: Bool: prints numerical errors at each step if true (default is false);\nmax_iter :: Int: maximum number of iterations of the Newton algorithm (default is 20);\ntol :: Real: relative tolerance measured in ℓ∞ norm (default is 1e-10);\nktol :: Real: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ngtol :: Real: relative tolerance of the GMRES algorithm (default is 1e-10);\ndealias :: Int: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nq :: Real: Newton algorithm modified with u_{n+1}=q*u_{n+1}+(1-q)*u_n (default is 1);\nα :: Real: adds α times spectral projection onto the Kernel to the Jacobian (default is 0).\n\nReturn values\n\n(η,u,v) with\n\nη :: Vector{Float64}: surface deformation;\nu :: Vector{Float64}: layer-averaged velocity;\nv :: Vector{Float64}: tangential velocity;\nmesh :: Mesh: mesh collocation points.\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.create_animation-Tuple{Any}","page":"Documentation","title":"WaterWaves1D.create_animation","text":"create_animation( problems; name::String, kwargs... )\n\nCreate an animation showing the evolution of initial-value problems.\n\nArgument problems is either an element or a collection (vector, list, etc.) of elements of type Problem.\n\nThe animation is saved as name.gif if name is provided.\n\nOther keyword arguments are as follows\n\nxlims allows to specifies the x axis limits for the surface deformation. If nothing is provided (default), then the full numerical basin is represented.\nylims allows to specifies the y axis limits for the surface deformation. If nothing is provided (default), then the limits are determined from the initial data. If anything but a Tuple is provided, the axis limits evolve with the solution.\nvlims and flims are as above, but for the velocity and Fourier coefficients plots.\nNframes gives the (maximal) number of frames in the animation.\nother arguments of plot_solution!\n\nReturn anim, an animation, which can then generate (for instance) a gif through gif(anim, \"my_name.gif\", fps=15).\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.interpolate-Tuple{Mesh, Any, Any}","page":"Documentation","title":"WaterWaves1D.interpolate","text":"interpolate(mesh,vector,x;fast)\n\nInterpolate a vector vector defined on a uniform collocation grid defined by mesh, on collocation points given by x.\n\nIf the collocation points x are regularly spaced and the optional keyword argument fast is set to true (default is false), then the algorithm is faster and uses less allocations, but is less precise.\n\nReturns the vector of values on collocation points.\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.interpolate-Tuple{Mesh, Any}","page":"Documentation","title":"WaterWaves1D.interpolate","text":"interpolate(mesh,vector;n=2^3)\n\nInterpolate a vector vector defined on a uniform collocation grid defined by mesh.\n\nReturns (new_mesh,new_vector) a new uniform mesh with n times as many values, and the vector of values on collocation points.\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.plot_difference!-Tuple{Any, Any}","page":"Documentation","title":"WaterWaves1D.plot_difference!","text":"plot_difference!( plt, problems ; t,x,interpolation,compression,fast,surface,velocity,fourier,label )\n\nPlots in plt the difference between solutions of initial-value problems at a given time.\n\nArgument\n\npairs is a either a collection (vector, list, etc.) of elements of type Problem, or of pairs of such elements. If pairs are provided, then solutions of such problems are compared. If a collection of problems are provided, then all possible pairs are compared.\n\nKeyword arguments (all optional)\n\nt is the time. If not provided, then the last computed time is plotted.\nif a vector x is provided and if possible, the solution is interpolated to the collocation points x.\nif interpolation is provided as an integer, the solution is interpolated on as many collocation points (if true, then the value 2^3 is chosen, default is false).\nif fast = false (default is false), then the second problem is interpolated to the collocation points of the first problem.\nif compression is provided as an integer m, only one in m points are plotted (if true, then the value 2^3 is chosen, default is false).\nsurface, velocity and fourier (booleans) determine respectively whether surface deformation, η, tangential velocity, v, and the Fourier coefficients of η (in log-scale) are plotted.\nlabel defines the label(s) if provided (otherwise labels are inferred from the problems).\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.plot_difference-Tuple{Any}","page":"Documentation","title":"WaterWaves1D.plot_difference","text":"plot_difference( pairs; t,x, interpolation,compression, surface,velocity,fourier, label )\n\nSame as plot_difference! but generates and returns the plot.\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.plot_solution!-Tuple{Any, Any}","page":"Documentation","title":"WaterWaves1D.plot_solution!","text":"plot_solution!( plt; problems; t,x,interpolation,compression,surface,velocity,fourier,label )\n\nPlots in plt the solution of initial-value problems at a given time.\n\nArgument\n\nproblems is either an element or a collection (vector, list, etc.) of elements of type Problem.\n\nKeyword arguments (all optional)\n\nt is the time. If not provided, then the last computed time is plotted.\nif a vector x is provided and if possible, the solution is interpolated to the collocation points x.\nif interpolation is provided as an integer, the solution is interpolated on as many collocation points (if true, then the value 2^3 is chosen, default is false).\nif compression is provided as an integer m, only one in m points are plotted (if true, then the value 2^3 is chosen, default is false).\nsurface, velocity and fourier (booleans) determine respectively whether surface deformation, η, tangential velocity, v, and the Fourier coefficients of η (in log-scale) are plotted.\nlabel defines the label(s) if provided (otherwise labels are inferred from the problems)\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.plot_solution-Tuple{Any}","page":"Documentation","title":"WaterWaves1D.plot_solution","text":"plot_solution( problems; t,x, interpolation,compression, surface,velocity,fourier, label )\n\nSame as plot_solution! but generates and returns the plot.\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.solution-Tuple{Problem}","page":"Documentation","title":"WaterWaves1D.solution","text":"solution(p::Problem;t,x,interpolation)\n\nGives the solution of a solved initial-value at a given time t.\n\nArguments\n\nArgument p is of type Problem.\nKeyword argument t is optional, the last computed time is returned by default.\nKeyword argument x is optional, if provided the solution is interpolated to the collocation vector x.\nKeyword argument interpolation is optional, if an integer is provided the solution is interpolated on as many collocation points (if true, then the default value 2^3 is chosen).\n\nReturn values\n\nProvides (η,v,x,t) where\n\nη is the surface deformation at collocation points;\nv is the tangential velocity (derivative of the trace of the velocity potential) at collocation points;\nx is the vector of collocation points;\nt the time (first computed time greater or equal to provided t).\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.solve!-Tuple{Any}","page":"Documentation","title":"WaterWaves1D.solve!","text":"solve!( problems; verbose=true )\n\nSolve (i.e. integrate in time) a collection of initial-value problems.\n\nThe argument problems should be a collection (list, array...) of elements of type Problem.\n\nInformation are not printed if keyword argument verbose = false (default is true).\n\n\n\n\n\n","category":"method"}]
}
