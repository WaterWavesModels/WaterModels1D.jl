var documenterSearchIndex = {"docs":
[{"location":"home/#WaterWaves1D.jl","page":"Home","title":"WaterWaves1D.jl","text":"","category":"section"},{"location":"home/#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"WaterWaves1D.jl is a Julia package providing a framework to study and compare several models for the propagation of unidimensional surface gravity waves (a.k.a. \"water waves\").","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"Several models are already implemented, including (but not limited to) the so-called water waves system, its truncated spectral expansion, the Green-Naghdi system, the Matsuno system, and so on. You may easily add your favorite one to the gang: see the how-to guide.","category":"page"},{"location":"home/#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"(v1.0) pkg> add https://github.com/WaterWavesModels/WaterWaves1D.jl.git\nusing WaterWaves1D","category":"page"},{"location":"home/#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"A simple example is documented here. More advanced examples can be found in the package's examples and notebooks section.","category":"page"},{"location":"home/#Developers","page":"Home","title":"Developers","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"WaterWaves1D.jl is being developed by Vincent Duchêne and Pierre Navaro.","category":"page"},{"location":"home/#Documentation-contents","page":"Home","title":"Documentation contents","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"Depth = 3\nPages = [\n        \"home.md\",\n        \"background.md\",\n        \"basics.md\",\n        \"example.md\",\n        \"index.md\"\n        ]","category":"page"},{"location":"basics/#Code-basics","page":"Code basics","title":"Code basics","text":"","category":"section"},{"location":"basics/","page":"Code basics","title":"Code basics","text":"Under construction","category":"page"},{"location":"basics/#How-to...","page":"Code basics","title":"How to...","text":"","category":"section"},{"location":"basics/#add-your-model","page":"Code basics","title":"add your model","text":"","category":"section"},{"location":"basics/#add-your-initial-data","page":"Code basics","title":"add your initial data","text":"","category":"section"},{"location":"basics/#add-your-solver","page":"Code basics","title":"add your solver","text":"","category":"section"},{"location":"background/#Background","page":"Background","title":"Background","text":"","category":"section"},{"location":"background/#Water-waves","page":"Background","title":"Water waves","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"While WaterWaves1D is dedicated to the propagation of unidimensional surface gravity waves (a.k.a. \"water waves\"), it provides a general framework and structures for numerically integrating initial-value problems","category":"page"},{"location":"background/#Models","page":"Background","title":"Models","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"A description of the models as PDES, with a link to the desired section.","category":"page"},{"location":"background/#Pseudospectral-methods","page":"Background","title":"Pseudospectral methods","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"All the systems described above are discretized (in the space variable) using the Fourier-based pseudospectral method. This method is particularly suitable for data which are either periodic or decaying at infinity, and fairly regular. In this framework one approaches data by a sum [...]","category":"page"},{"location":"#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"","category":"page"},{"location":"#Initial-data","page":"Index","title":"Initial data","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Pages   = [ \"index/#initial-data.md\" ]","category":"page"},{"location":"","page":"Index","title":"Index","text":"Modules = [WaterWaves1D]\n#Filter = t -> typeof(t) === DataType && t <: InitialData # this filters out useful functions, so it is better to include specific pages\nPages = [\n\"CnoidalWaveSerreGreenNaghdi.jl\",\n\"SolitaryWaveSerreGreenNaghdi.jl\",\n\"SolitaryWaveWhithamGreenNaghdi.jl\",\n\"SolitaryWaveWhithamBoussinesq.jl\",\n\"SolitaryWaveWhitham.jl\",\n\"Random.jl\"]\n","category":"page"},{"location":"#WaterWaves1D.CnoidalSGN","page":"Index","title":"WaterWaves1D.CnoidalSGN","text":"CnoidalSGN(param; P=1)\n\nBuild the initial data associated with CnoidalWaveSerreGreenNaghdi(param; P=1), of type InitialData, to be used in initial-value problems Problem(model, initial::InitialData, param).\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.CnoidalWaveSerreGreenNaghdi-Tuple{NamedTuple}","page":"Index","title":"WaterWaves1D.CnoidalWaveSerreGreenNaghdi","text":"CnoidalWaveSerreGreenNaghdi(param; P=1)\n\nCompute the Serre-Green-Naghdi cnoidal wave with prescribed h₀<h₁<h₂. h₁ is the minimum, h₂ is the maximum of the wave. As h₀ -> h₁, the cnoidal wave converges towards the solitary wave. See for instance Gavrilyuk, Nkonga, Shyue and Truskinovsky, doi:10.1088/1361-6544/ab95ac\n\nArguments\n\nparam :: NamedTuple: parameters of the problem containing h₀<h₁<h₂ and dimensionless parameters ϵ and μ, and number of collocation points N.\nP :: Int: (keyword, optional, default = 1) the number of periods of the cnoidal wave in the constructed mesh.\n\nReturn values\n\n(η,u,v,mesh,param) with\n\nη :: Vector{Float64}: surface deformation;\nu :: Vector{Float64}: layer-averaged velocity;\nv :: Vector{Float64}: derivative of the trace of the velocity potential at the surface;\nmesh :: Mesh: mesh collocation points;\nparam :: NamedTuple: useful parameters\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.SolitarySGN","page":"Index","title":"WaterWaves1D.SolitarySGN","text":"SolitarySGN(param; x₀=0)\n\nBuild the initial data associated with SolitaryWaveSerreGreenNaghdi(param; x₀=0), of type InitialData, to be used in initial-value problems Problem(model, initial::InitialData, param).\n\n\n\nSolitarySGN(c; ϵ=1,μ=1,x₀=0,N=2^12)\n\nBuild the initial data with velocity c, center x₀, dimensionless parameters ϵ and μ, and number of collocation points N.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.SolitaryWaveSerreGreenNaghdi-Tuple{NamedTuple}","page":"Index","title":"WaterWaves1D.SolitaryWaveSerreGreenNaghdi","text":"SolitaryWaveSerreGreenNaghdi(param; x₀=0)\n\nCompute the Serre-Green-Naghdi solitary wave with prescribed velocity.\n\nArguments\n\nparam :: NamedTuple: parameters of the problem containing velocity c and dimensionless parameters ϵ and μ, and mesh size L and number of collocation points N;\nx₀ :: Real: (keyword, optional, default = 0) center of solitary wave.\n\nReturn values\n\n(η,u,v,mesh) with\n\nη :: Vector{Float64}: surface deformation;\nu :: Vector{Float64}: layer-averaged velocity;\nv :: Vector{Float64}: derivative of the trace of the velocity potential at the surface;\nmesh :: Mesh: mesh collocation points.\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.SolitaryWGN","page":"Index","title":"WaterWaves1D.SolitaryWGN","text":"SolitaryWGN(param; kwargs)\n\nBuild the initial data associated with SolitaryWaveWhithamGreenNaghdi(param; kwargs), of type InitialData, to be used in initial-value problems Problem(model, initial::InitialData, param).\n\n\n\nSolitaryWGN(c; ϵ=1,μ=1,N=2^12,kwargs)\n\nBuild the initial data with velocity c, dimensionless parameters ϵ and μ, and number of collocation points N, and kwargs the other (optional) keyword arguments as above.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.SolitaryWaveWhithamGreenNaghdi-Tuple{NamedTuple}","page":"Index","title":"WaterWaves1D.SolitaryWaveWhithamGreenNaghdi","text":"SolitaryWaveWhithamGreenNaghdi(param; kwargs)\n\nCompute the Whitham-Green-Naghdi solitary wave with prescribed velocity.\n\nArguments\n\nparam :: NamedTuple: parameters of the problem containing velocity c and dimensionless parameters ϵ and μ, and mesh size L and number of collocation points N;\n\nKeywords (optional)\n\nguess :: Vector{Real}: initial guess for the surface deformation (if not provided, the exact formula for SGN is used);\nx₀ :: Real: center of solitary wave (if guess is not provided);\nSGN :: Bool: if true computes the Serre-Green-Naghdi (instead of Whitham-Green-Naghdi) solitary wave (consider SolitaryWaveSerreGreenNaghdi instead);\nmethod :: Int: equation used (between 1 and 4);\niterative :: Bool: inverts Jacobian through GMRES if true, LU decomposition if false (default is false);\nverbose :: Bool: prints numerical errors at each step if true (default is false);\nmax_iter :: Int: maximum number of iterations of the Newton algorithm (default is 20);\ntol :: Real: relative tolerance measured in ℓ∞ norm (default is 1e-10);\nktol :: Real: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ngtol :: Real: relative tolerance of the GMRES algorithm (default is 1e-10);\ndealias :: Int: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nq :: Real: Newton algorithm modified with u_{n+1}=q*u_{n+1}+(1-q)*u_n (default is 1);\nα :: Real: adds α times spectral projection onto the Kernel to the Jacobian (default is 0).\n\nReturn values\n\n(η,u,v,mesh) with\n\nη :: Vector{Float64}: surface deformation;\nu :: Vector{Float64}: layer-averaged velocity;\nv :: Vector{Float64}: derivative of the velocity potential at the surface;\nmesh :: Mesh: mesh collocation points.\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.SolitaryWB","page":"Index","title":"WaterWaves1D.SolitaryWB","text":"SolitaryWB(param; kwargs)\n\nBuild the initial data associated with SolitaryWaveWhithamBoussinesq(param; kwargs), of type InitialData, to be used in initial-value problems Problem(model, initial::InitialData, param).\n\n\n\nSolitaryWB(c; ϵ=1,μ=1,N=2^12,kwargs)\n\nBuild the initial data with velocity c, dimensionless parameters ϵ and μ, and number of collocation points N, and kwargs the other (optional) keyword arguments as above.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.SolitaryWaveWhithamBoussinesq-Tuple{NamedTuple}","page":"Index","title":"WaterWaves1D.SolitaryWaveWhithamBoussinesq","text":"SolitaryWaveWhithamBoussinesq(param; kwargs)\n\nCompute the Whitham-Boussinesq solitary wave with prescribed velocity.\n\nArgument\n\nparam :: NamedTuple: parameters of the problem containing velocity c and dimensionless parameters ϵ and μ,\n\nand mesh size L and number of collocation points N;\n\nKeywords (optional)\n\nguess :: Vector{Real}: initial guess for the surface deformation (if not provided, the exact formula for SGN is used);\nx₀ :: Real: center of solitary wave (if guess is not provided);\nα :: Real: determines the model used (typically 1 or 1/2, default is 1);\nBoussinesq: if true (default is false), compute the standard Boussinesq system with parameters a (defaut -1//3), b=d (defaut 1//3), and c=0);\niterative :: Bool: inverts Jacobian through GMRES if true, LU decomposition if false;\nverbose :: Bool: prints numerical errors at each step if true;\nmax_iter :: Int: maximum number of iterations of the Newton algorithm;\ntol :: Real: general tolerance (default is 1e-10);\nktol :: Real: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ngtol :: Real: relative tolerance of the GMRES algorithm (default is 1e-10);\ndealias :: Int: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nq :: Real: Newton algorithm modified with\n\nu_{n+1}=q*(u_n+du)+(1-q)*u_n (default is 1);\n\nβ :: Real: adds β times spectral projection onto the Kernel to the Jacobian.β\n\nReturn values\n\n(η,v,mesh) with\n\nη :: Vector{Float64}: surface deformation;\nv :: Vector{Float64}: velocity (derivative of the trace of the velocity potential at the surface);\nmesh :: Mesh: mesh collocation points.\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.SolitaryWhitham","page":"Index","title":"WaterWaves1D.SolitaryWhitham","text":"SolitaryWhitham(param; kwargs)\n\nBuild the initial data associated with SolitaryWaveWhitham(param; kwargs), of type InitialData, to be used in initial-value problems Problem(model, initial::InitialData, param).\n\n\n\nSolitaryWhitham(c; ϵ=1,μ=1,N=2^12,kwargs)\n\nBuild the initial data with velocity c, dimensionless parameters ϵ and μ, and number of collocation points N, and kwargs the other (optional) keyword arguments as above.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.SolitaryWaveWhitham-Tuple{NamedTuple}","page":"Index","title":"WaterWaves1D.SolitaryWaveWhitham","text":"SolitaryWaveWhitham(param; kwargs)\n\nCompute the Whitham solitary wave with prescribed velocity.\n\nArgument\n\nparam :: NamedTuple: parameters of the problem containing velocity c and dimensionless parameters ϵ and μ, and mesh size L and number of collocation points N;\n\nKeywords (optional)\n\nguess :: Vector{Real}: initial guess for the surface deformation (if not provided, the exact formula for KdV is used);\nx₀ :: Real: center of solitary wave (if guess is not provided);\niterative :: Bool: inverts Jacobian through GMRES if true, LU decomposition if false;\nverbose :: Bool: prints numerical errors at each step if true;\nmax_iter :: Int: maximum number of iterations of the Newton algorithm;\ntol :: Real: general tolerance (default is 1e-10);\nktol :: Real: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ngtol :: Real: relative tolerance of the GMRES algorithm (default is 1e-10);\ndealias :: Int: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nq :: Real: Newton algorithm modified with\n\nu_{n+1}=q*u_{n+1}+(1-q)*u_n (default is 1);\n\nα :: Real: adds α times spectral projection onto the Kernel to the Jacobian;\nKdV :: Bool: if true computes the KdV (instead of Whitham) solitary wave.\n\nReturn values\n\n(u,mesh) with\n\nu :: Vector{Float64}: the solution;\nmesh :: Mesh: mesh collocation points.\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.Random","page":"Index","title":"WaterWaves1D.Random","text":"Random(mesh::Mesh;args)\n\nRandomly generated initial data, based on provided (optional arguments) :\n\nL is the typical wavelength (default is L=1),\ns is the (real) Sobolev index regularity (default is s=∞),\nλ is the length of spatial localization (default is λ=∞, no localization),\na is the couple of amplitudes of the surface deformation, and velocity (default is a=(1,1)).\n\nReturn an initial data init::InitialData,  to be used in initial-value problems Problem(model, init, param), with init.η and init.v two samples of random(x;L,s,λ), where x is the set of collocation points generated by Mesh(param).\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.random-Tuple{Any}","page":"Index","title":"WaterWaves1D.random","text":"random(x;args)\n\nRandomly generate a vector of size x, based on provided (optional arguments) :\n\nL is the typical wavelength (default is L=1),\ns is the (real) Sobolev index regularity (default is s=∞, smooth data),\nλ is the length of spatial localization (default is λ=∞, no localization),\na is the amplitude of the returned vector (default is a=1).\n\nThe vector is generated through randomly chosen Fourier coefficients, multiplied with weigth w=10^(-|k|L/(2π)) if s=∞, or w=1/(1+9(|k|L/(2π))^(s+1/2)) otherwise. If λ≠∞, the function in spatial variables is multiplied by exp(-|x/λ|^2), and in any case normalized to have maximum absolute value 1.\n\n\n\n\n\n","category":"method"},{"location":"#Models","page":"Index","title":"Models","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Pages   = [ \"/#models\" ]","category":"page"},{"location":"","page":"Index","title":"Index","text":"Modules = [WaterWaves1D]\nFilter = t -> typeof(t) === DataType && t <: AbstractModel","category":"page"},{"location":"#WaterWaves1D.Boussinesq","page":"Index","title":"WaterWaves1D.Boussinesq","text":"Boussinesq(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for abcd-Boussinesq models (with b=d and c=0). See Bona, Chen, and Saut\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param).\n\nOptional keyword arguments\n\ntwo parameters a (default is -1/3) and b (default is +1/3) which determine the model solved. You need a+2*b=1/3 for validity as a long wave model (without surface tension).\nktol: tolerance of the low-pass Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"Boussinesq\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function Boussinesq.f! to be called in explicit time-integration solvers;\na function Boussinesq.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function Boussinesq.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is the derivative of the trace of the velocity potential.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.DeepQuadratic","page":"Index","title":"WaterWaves1D.DeepQuadratic","text":"DeepQuadratic(param;dealias,label)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the quadratic deep-water model proposed by Akers and Milewski and Cheng, Granero-Belinchón, Shkoller and Milewski\n\nArguments\n\nparam is of type NamedTuple and must contain\n\nthe dimensionless parameters ϵ (nonlinearity);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param).\n\nOptional keyword arguments\n\ndealias: dealiasing with 1/3 Orlicz rule if true or no dealiasing if false (by default);\nlabel: a label for future references (default is \"deep quadratic\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function DeepQuadratic.f! to be called in explicit time-integration solvers;\na function DeepQuadratic.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function DeepQuadratic.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is given by ∂t η = - ∂x v.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.DeepQuadratic_fast","page":"Index","title":"WaterWaves1D.DeepQuadratic_fast","text":"DeepQuadratic_fast(param;dealias,label)\n\nSame as DeepQuadratic, but faster.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.IsobeKakinuma","page":"Index","title":"WaterWaves1D.IsobeKakinuma","text":"IsobeKakinuma(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the Isobe-Kakinuma model.\n\nArgument\n\nparam is of type NamedTuple (or a collection NamedTuples) of and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param).\n\nOptional keyword arguments\n\niterative: solve the elliptic problem through GMRES if true, LU decomposition if false (default is true);\nprecond: use a (left) preconditioner for GMRES if true (default), choose precond as the preconditioner if provided;\ngtol: relative tolerance of the GMRES algorithm (default is 1e-14);\nrestart: the corresponding option of the GMRES algorithm (default is 100);\nmaxiter: the corresponding option of GMRES (default is nothing);\nktol: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"Isobe-Kakinuma\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function IsobeKakinuma.f! to be called in explicit time-integration solvers;\na function IsobeKakinuma.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function IsobeKakinuma.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is the derivative of the trace of the velocity potential;\nadditionally, a handy function IsobeKakinuma.mapfrofull which from data matrix returns the Tuple of real vectors (η,v,Φ), where\nΦ is the Vector of the basis functions ϕi (i∈{0,...,N}).\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.Matsuno","page":"Index","title":"WaterWaves1D.Matsuno","text":"Matsuno(param;dealias,label)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the quadratic deep-water model proposed by Matsuno.\n\nArguments\n\nparam is of type NamedTuple and must contain\n\nthe dimensionless parameters ϵ (nonlinearity);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param).\n\nOptional keyword arguments\n\ndealias: dealiasing with 1/3 Orlicz rule if true or no dealiasing if false (by default);\nlabel: a label for future references (default is \"Matsuno\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function DeepQuadratic.f! to be called in explicit time-integration solvers;\na function DeepQuadratic.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function DeepQuadratic.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is a velocity variable which is not the derivative of the trace of the velocity potential (if not null).\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.Matsuno_fast","page":"Index","title":"WaterWaves1D.Matsuno_fast","text":"Matsuno_fast(param;dealias,label)\n\nSame as Matsuno, but faster.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.NonHydrostatic","page":"Index","title":"WaterWaves1D.NonHydrostatic","text":"NonHydrostatic(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the \"Non-hydrostatic\" model proposed by Bristeau, Mangeney, Sainte-Marie and Seguin\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param).\n\nOptional keyword arguments\n\niterative: solve the elliptic problem through GMRES if true, LU decomposition if false (default is true);\nprecond: use a (left) preconditioner for GMRES if true (default), choose precond as the preconditioner if provided;\ngtol: relative tolerance of the GMRES algorithm (default is 1e-14);\nrestart: the corresponding option of the GMRES algorithm (default is 100);\nmaxiter: the corresponding option of GMRES (default is nothing);\nktol: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"non-hydrostatic\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function NonHydrostatic.f! to be called in explicit time-integration solvers;\na function NonHydrostatic.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function NonHydrostatic.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is the derivative of the trace of the velocity potential;\nadditionally, a handy function NonHydrostatic.mapfrofull which from data matrix returns the Tuple of real vectors (η,v,u), where\nu corresponds to the layer-averaged velocity.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.SerreGreenNaghdi","page":"Index","title":"WaterWaves1D.SerreGreenNaghdi","text":"SerreGreenNaghdi(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the Serre-Green-Naghdi model\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param).\n\nOptional keyword arguments\n\niterative: solve the elliptic problem through GMRES if true, LU decomposition if false (default is true);\nprecond: use a (left) preconditioner for GMRES if true (default), choose precond as the preconditioner if provided;\ngtol: relative tolerance of the GMRES algorithm (default is 1e-14);\nrestart: the corresponding option of the GMRES algorithm (default is 100);\nmaxiter: the corresponding option of GMRES (default is nothing);\nktol: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"Green-Naghdi\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function SerreGreenNaghdi.f! to be called in explicit time-integration solvers;\na function SerreGreenNaghdi.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function SerreGreenNaghdi.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is the derivative of the trace of the velocity potential;\nadditionally, a handy function SerreGreenNaghdi.mapfrofull which from data matrix returns the Tuple of real vectors (η,v,u), where\nu corresponds to the layer-averaged velocity.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.SquareRootDepth","page":"Index","title":"WaterWaves1D.SquareRootDepth","text":"SquareRootDepth(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the \"√D\" model proposed by Cotter, Holm and Percival\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param).\n\nOptional keyword arguments\n\niterative: solve the elliptic problem through GMRES if true, LU decomposition if false (default is true);\nprecond: use a (left) preconditioner for GMRES if true (default), choose precond as the preconditioner if provided;\ngtol: relative tolerance of the GMRES algorithm (default is 1e-14);\nrestart: the corresponding option of the GMRES algorithm (default is 100);\nmaxiter: the corresponding option of GMRES (default is nothing);\nktol: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"square-root depth\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function SquareRootDepth.f! to be called in explicit time-integration solvers;\na function SquareRootDepth.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function SquareRootDepth.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is the derivative of the trace of the velocity potential;\nadditionally, a handy function SquareRootDepth.mapfrofull which from data matrix returns the Tuple of real vectors (η,v,u), where\nu corresponds to the layer-averaged velocity.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.WWn","page":"Index","title":"WaterWaves1D.WWn","text":"WWn(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the water waves expansion proposed by Dommermuth and Yue (doi:10.1017/s002211208700288x), West et al. (doi:10.1029/jc092ic11p11803), Craig and Sulem (doi:10.1006/jcph.1993.1164) (see also the account by Choi : Fifth-order nonlinear spectral model for surface gravity waves: From pseudo-spectral to spectral formulations, RIMS Kokyuroku, 2019) with the \"rectification\" method proposed by Duchêne and Melinand.\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param)\n\nOptional keyword arguments\n\nν: shallow/deep water multiplication factor. By default, ν=1 if μ≦1 and ν=1/√μ otherwise. Set the infinite-layer case if ν=0 (or μ=Inf).\nIL: Set the infinite-layer case if IL=true (or μ=Inf, or ν=0), in which case ϵ is the steepness parameter. Default is false.\nn :: Int: the order of the expansion; linear system if 1, quadratic if 2, cubic if 3, quartic if 4 (default and other values yield 2);\nδ and m: parameters of the rectifier operator, set as k->min(1,|δ*k|^m) or k->min(1,|δ*k|^m[1]*exp(1-|δ*k|^m[2])) if m is a couple\n\n(by default is δ=0, i.e. no regularization and m=-1. Notice m=-Inf and δ>0 yields a cut-off filter);\n\nktol: tolerance of the low-pass Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"WWn\" with n the order of the expansion);\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function WWn.f! to be called in explicit time-integration solvers (also WWn.f1! and WWn.f2! for the symplectic Euler solver);\na function WWn.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function WWn.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is the derivative of the trace of the velocity potential.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.WaterWaves","page":"Index","title":"WaterWaves1D.WaterWaves","text":"WaterWaves(param; kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the water waves system (via conformal mapping, see Zakharov, Dyachenko and Vasilyev).\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param).\n\nOptional keyword arguments\n\nν: shallow/deep water multiplication factor (see Lannes, The water waves problem). By default, ν=1 if μ≦1 and ν=1/√μ otherwise.\nIL: Set the infinite-layer case if IL=true (or μ=Inf, or ν=0), in which case ϵ is the steepness parameter. Default is false.\nmethod ∈ {1,2,3}: method used to initialize the conformal mapping, as a fix-point problem F(u)=u\nif method == 1, use standard contraction fix-point iteration;\nif method == 2, use Newton algorithm with GMRES iterative solver to invert the Jacobian;\nif method == 3, use Newton algorithm with direct solver to invert the Jacobian;\ntol: (relative) tolerance of the fix-point algorithm (default is 1e-16);\nmaxiter: the maximal number of iteration in the fix-point algorithm (default is 100);\nktol: tolerance of the low-pass Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"water waves\");\nverbose: prints information if true (default is true).\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function WaterWaves.f! to be called in the explicit time-integration solver (also WaterWaves.f1! and WaterWaves.f2! for the symplectic Euler solver);\na function WaterWaves.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function WaterWaves.mapfro which from such data matrix returns the Tuple of real vectors (x,η,v), where\nx is a vector of collocation points (non-regularly spaced);\nη is the surface deformation at points x;\nv is the derivative of the trace of the velocity potential at points x.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.WhithamBoussinesq","page":"Index","title":"WaterWaves1D.WhithamBoussinesq","text":"WhithamBoussinesq(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for a Boussinesq-type model with full-dispersion property.\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param)\n\nOptional keyword arguments\n\nBoussinesq: if true (default is false), compute the standard Boussinesq system instead (see Boussinesq(param;kwargs));\na parameter α which determines the model solved:\nIf α = 1 (default), then the model has been introduced in Dinvay, Dutykh and Kalisch;\nIf α = 1/2, then the model is a quasilinear version;\nIf α < 1/2, then expect instabilities stemming from ill-posedness of the model.\nktol: tolerance of the low-pass Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"Whitham-Boussinesq\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function WhithamBoussinesq.f! to be called in explicit time-integration solvers;\na function WhithamBoussinesq.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed.\na function WhithamBoussinesq.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is the derivative of the trace of the velocity potential.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.WhithamGreenNaghdi","page":"Index","title":"WaterWaves1D.WhithamGreenNaghdi","text":"WhithamGreenNaghdi(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the fully dispersive Green-Naghdi model proposed by Duchêne, Israwi and Talhouk.\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param).\n\nOptional keyword arguments\n\nSGN: if true (default is false), compute the Serre-Green-Naghdi (SGN) instead of Whitham-Green-Naghdi (WGN) system (see SerreGreenNaghdi(param;kwargs));\niterative: solve the elliptic problem through GMRES if true, LU decomposition if false (default is true);\nprecond: use a (left) preconditioner for GMRES if true (default), choose precond as the preconditioner if provided;\ngtol: relative tolerance of the GMRES algorithm (default is 1e-14);\nrestart: the corresponding option of the GMRES algorithm (default is 100);\nmaxiter: the corresponding option of GMRES (default is nothing);\nktol: tolerance of the Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"Whitham-Green-Naghdi\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function WhithamGreenNaghdi.f! to be called in explicit time-integration solvers;\na function WhithamGreenNaghdi.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function WhithamGreenNaghdi.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is the derivative of the trace of the velocity potential;\nadditionally, a handy function WhithamGreenNaghdi.mapfrofull which from data matrix returns the Tuple of real vectors (η,v,u), where\nu corresponds to the layer-averaged velocity.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.modifiedMatsuno","page":"Index","title":"WaterWaves1D.modifiedMatsuno","text":"modifiedMatsuno(param;kwargs)\n\nDefine an object of type AbstractModel in view of solving the initial-value problem for the modified Matsuno model\n\nArgument\n\nparam is of type NamedTuple and must contain\n\ndimensionless parameters ϵ (nonlinearity) and μ (dispersion);\nnumerical parameters to construct the mesh of collocation points as mesh = Mesh(param)\n\nOptional keyword arguments\n\nν: shallow/deep water multiplication factor. By default, ν=1 if μ≦1 and ν=1/√μ otherwise. Set the infinite-layer case if ν=0 (or μ=Inf).\nIL: Set the infinite-layer case if IL=true (or μ=Inf, or ν=0), in which case ϵ is the steepness parameter. Default is false.\nktol: tolerance of the low-pass Krasny filter (default is 0, i.e. no filtering);\ndealias: dealiasing with Orlicz rule 1-dealias/(dealias+2) (default is 0, i.e. no dealiasing);\nlabel: a label for future references (default is \"modified Matsuno\");\n\nReturn values\n\nGenerate necessary ingredients for solving an initial-value problem via solve!:\n\na function modifiedMatsuno.f! to be called in explicit time-integration solvers;\na function modifiedMatsuno.mapto which from (η,v) of type InitialData provides the raw data matrix on which computations are to be executed;\na function modifiedMatsuno.mapfro which from such data matrix returns the Tuple of real vectors (η,v), where\nη is the surface deformation;\nv is the derivative of the trace of the velocity potential.\n\n\n\n\n\n","category":"type"},{"location":"#Solvers","page":"Index","title":"Solvers","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Pages   = [ \"index#solvers.md\" ]","category":"page"},{"location":"","page":"Index","title":"Index","text":"Modules = [WaterWaves1D]\nFilter = t -> typeof(t) === DataType && t <: TimeSolver","category":"page"},{"location":"#WaterWaves1D.Euler","page":"Index","title":"WaterWaves1D.Euler","text":"Euler(arguments;realdata)\n\nExplicit Euler solver.\n\nConstruct an object of type TimeSolver to be used in Problem(model, initial, param; solver::TimeSolver)\n\nArguments can be either\n\nan object of type AbstractModel;\nan Array of size (N,m) where N is the number of collocation points and m the number of data (equations solved);\na Tuple (N,m) as above;\nan integer N and an integer m as above (the latter is optional, by default m=2).\na NamedTuple containing a key N and an integer m (the latter is optional, by default m=2).\n\nThe keyword argument realdata is optional, and determines whether pre-allocated vectors are real- or complex-valued. By default, they are either determined by the model or the type of the array in case 0. and 1., complex-valued otherwise.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.EulerSymp","page":"Index","title":"WaterWaves1D.EulerSymp","text":"EulerSymp(arguments;Niter,implicit,realdata)\n\nSymplectic Euler solver. The implicit Euler method is first used on one equation, then the explicit Euler method is used on the second one. The implicit equation is solved via Neumann iteration\n\nConstruct an object of type TimeSolver to be used in Problem(model, initial, param; solver::TimeSolver)\n\nArguments can be either\n\nan object of type AbstractModel;\nan Array of size (N,2) where N is the number of collocation points;\nan integer N being the number of collocation points;\na NamedTuple containing a key N.\n\nThe keyword argument Niter (optional, defaut value = 10) determines the number of steps in the Neumann iteration solver of the implicit step. The keyword argument implicit (optional, defaut value = 1) determines which equation is implicit (must be 1 or 2). The keyword argument realdata is optional, and determines whether pre-allocated vectors are real- or complex-valued. By default, they are either determined by the model or the type of the array in case 0. and 1., complex-valued otherwise.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.Euler_naive","page":"Index","title":"WaterWaves1D.Euler_naive","text":"Euler_naive()\n\nRunge-Kutta fourth order solver.\n\nA naive version of Euler, without argument since no pre-allocation is performed.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.RK4","page":"Index","title":"WaterWaves1D.RK4","text":"RK4(arguments;realdata)\n\nExplicit Runge-Kutta fourth order solver.\n\nConstruct an object of type TimeSolver to be used in Problem(model, initial, param; solver::TimeSolver)\n\nArguments can be either\n\nan object of type AbstractModel;\nan Array of size (N,m) where N is the number of collocation points and m the number of data (equations solved);\na Tuple (N,m) as above;\nan integer N and an integer m as above (the latter is optional, by default m=2).\na NamedTuple containing a key N and an integer m (the latter is optional, by default m=2).\n\nThe keyword argument realdata is optional, and determines whether pre-allocated vectors are real- or complex-valued. By default, they are either determined by the model in case 1., complex-valued otherwise.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.RK4_naive","page":"Index","title":"WaterWaves1D.RK4_naive","text":"RK4_naive()\n\nRunge-Kutta fourth order solver.\n\nA naive version of RK4, without argument since no pre-allocation is performed.\n\n\n\n\n\n","category":"type"},{"location":"#Tools","page":"Index","title":"Tools","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Modules = [WaterWaves1D]\nPages   = [\n\"init.jl\",\n\"tools.jl\",\n\"mesh.jl\",\n\"problem.jl\",\n\"data.jl\",\n\"times.jl\"]","category":"page"},{"location":"#WaterWaves1D.Init","page":"Index","title":"WaterWaves1D.Init","text":"Init(data ; fast, label)\n\nGenerate an initial data to be used in the function Problem.\n\ndata should contain either\n\na function η and a function v (in this order)\na Namedtuple with a function η and a function v\na mesh and two vectors representing η(mesh.x) and v(mesh.x) (in this order)\na mesh and a Namedtuple with a vector η and a vector v as above\nan array of collocation points and two vectors representing η(x) and v(x) (in this order)\na mesh and a Namedtuple with a vector η and a vector v as above\n\nIn the last four cases, an optional keyword argument fast can be set to true, (default is false), in which case the algorithm is faster and uses less allocations, but is less precise.\n\nIn the last two cases, the collocation points must be regularly spaced, otherwise an ErrorException is raised.\n\nIf the keyword label::String (used to display information to the output stream) is not provided, then it is set to the \"user-defined\".\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.interpolate-Tuple{Mesh, Any, Any}","page":"Index","title":"WaterWaves1D.interpolate","text":"interpolate(mesh,vector,x;fast)\n\nInterpolate a vector vector defined on a uniform collocation grid defined by mesh, on collocation points given by x.\n\nIf the collocation points x are regularly spaced and the optional keyword argument fast is set to true (default is false), then the algorithm is faster and uses less allocations, but is less precise.\n\nReturns the vector of values on collocation points.\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.interpolate-Tuple{Mesh, Any}","page":"Index","title":"WaterWaves1D.interpolate","text":"interpolate(mesh,vector;n=2^3)\n\nInterpolate a vector vector defined on a uniform collocation grid defined by mesh.\n\nReturns (new_mesh,new_vector) a new uniform mesh with n times as many values, and the vector of values on collocation points.\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.solution-Tuple{Problem}","page":"Index","title":"WaterWaves1D.solution","text":"solution(p::Problem;t,x,interpolation)\n\nGives the solution of a solved initial-value at a given time t.\n\nArguments\n\nArgument p is of type Problem.\nKeyword argument t is optional, the last computed time is returned by default.\nKeyword argument x is optional, if provided the solution is interpolated to the collocation vector x.\nKeyword argument interpolation is optional, if an integer is provided the solution is interpolated on as many collocation points (if true, then the default value 2^3 is chosen).\n\nReturn values\n\nProvides (η,v,x,t) where\n\nη is the surface deformation at collocation points;\nv is the tangential velocity (derivative of the trace of the velocity potential) at collocation points;\nx is the vector of collocation points;\nt the time (first computed time greater or equal to provided t).\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.Mesh","page":"Index","title":"WaterWaves1D.Mesh","text":"Mesh(args)\n\nConstructs a mesh of collocation points and associated Fourier modes.\n\nArguments\n\nCan be either\n\nxmin, xmax, and N; or\nL, N (same as above with xmin=-L and xmax=L); or\nparam :: NamedTuple, a NamedTuple containing N and L or xmin and xmax, then same as above; or\nx a vector of regularly spaced collocation points`.\n\nThe mesh as N collocation points regularly spaced between xmin (included) and xmax (excluded)\n\nReturn values\n\nm=Mesh(args) is of parametric type and offers with\n\nm.N: number of collocation points and Fourier modes;\nm.xmin: minimum of the mesh (included in the vector of collocation points);\nm.xmax: maximum of the mesh (excluded in the vector of collocation points);\nm.dx: distance between two collocation points;\nm.x: the vector of collocation points;\nm.kmin: minimum of Fourier modes (included in the vector of Fourier modes);\nm.kmax: maximum of Fourier modes (included in the vector of Fourier modes);;\nm.dk: distance between two Fourier modes;\nm.k: the vector of Fourier modes.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.Problem","page":"Index","title":"WaterWaves1D.Problem","text":"Problem( model, initial, param ; solver, label)\n\nBuild an initial-value problem which can then be solved (i.e. integrated in time) through solve!( problem )\n\nArguments\n\nmodel   :: AbstractModel,  the system of equation solved.\n\nMay be built, e.g., by WaterWaves(param);\n\ninitial :: InitialData, the initial data.\n\nMay be buit, e.g., by Init(η,v) where η is the surface deformation and v the derivative of the trace of the velocity potential at the surface;\n\nparam   :: NamedTuple, must contain values for\nN, the number of collocation points of the spatial grid\nL, the half-length of the spatial grid\nT, the final time of integration\ndt, the timestep\nadditionally, it may contain Ns the number of computed data or ns for storing data every ns computation steps (by default, every computed data is stored).\n\nOptional keyword arguments\n\nsolver :: TimeSolver, the solver for time integration (default is explicit Runge-Kutta fourth order solver).\n\nMay be built, e.g., by RK4(model) or RK4_naive().\n\nlabel   :: String is used in future references (e.g.plot_solution`).\nInformation are not printed if verbose = false (default is true).\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.solve!-Tuple{Any}","page":"Index","title":"WaterWaves1D.solve!","text":"solve!( problems; verbose=true )\n\nSolve (i.e. integrate in time) a collection of initial-value problems.\n\nThe argument problems should be a collection (list, array...) of elements of type Problem.\n\nInformation are not printed if keyword argument verbose = false (default is true).\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.solve!-Tuple{Problem}","page":"Index","title":"WaterWaves1D.solve!","text":"solve!( problem :: Problem; verbose=true )\n\nSolve (i.e. integrate in time) an initial-value problem\n\nThe argument problem should be of type Problem. It may be buit, e.g., by Problem(model, initial, param)\n\nInformation are not printed if keyword argument verbose = false (default is true).\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.Data","page":"Index","title":"WaterWaves1D.Data","text":"Data( mm :: Matrix )\n\nData structure to store the solution of an initial-value problem along time.\n\ndata=Data(m) is of parametric type and offers\n\ndata.U, a 1-element vector with a copy of the matrix m;\n(data.datalength,data.datasize)=size(m)  where datalength is the number of computed modes, and datasize the number of involved equations, typically 2.\n\n\n\n\n\n","category":"type"},{"location":"#WaterWaves1D.Times","page":"Index","title":"WaterWaves1D.Times","text":"Times(param; ns, Ns)\n\nConstructs a mesh of times, to be used in initial-value problems (see Problem).\n\nArguments\n\nparam is either\n\ndt,T with dt the timestep and T the final time of comuptation; or\na NamedTuple containing dt and T\n\nOptional keyword arguments\n\nns  : data are stored every ns computations (optional, default = 1).\nNs  : Ns data (in addition to the initial datum) are stored (optional, by default `floor( tfin/dt)).\n\nIf both Ns and ns are given, Ns overrules ns.\n\nReturn values\n\nt=Times(args) is of parametric type and offers\n\nt.Nc: number of computed times (including initial datum);\nt.Ns: number of stored times (including initial datum);\nt.ns: number of computed times between two stored times;\nt.tfin: the final time;\nt.dt: the timestep;\nt.tc : the vector of computed times;\nt.ts: the vector of stored times.\n\n\n\n\n\n","category":"type"},{"location":"#Graphics","page":"Index","title":"Graphics","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Modules = [WaterWaves1D]\nPages   = [\"figures.jl\"]","category":"page"},{"location":"#WaterWaves1D.create_animation-Tuple{Any}","page":"Index","title":"WaterWaves1D.create_animation","text":"create_animation( problems; name::String, kwargs... )\n\nCreate an animation showing the evolution of initial-value problems.\n\nArgument problems is either an element or a collection (vector, list, etc.) of elements of type Problem.\n\nThe animation is saved as name.gif if name is provided.\n\nOther keyword arguments are as follows\n\nxlims allows to specifies the x axis limits for the surface deformation. If nothing is provided (default), then the full numerical basin is represented.\nylims allows to specifies the y axis limits for the surface deformation. If nothing is provided (default), then the limits are determined from the initial data. If anything but a Tuple is provided, the axis limits evolve with the solution.\nvlims and flims are as above, but for the velocity and Fourier coefficients plots.\nNframes gives the (maximal) number of frames in the animation.\nother arguments of plot_solution!\n\nReturn anim, an animation, which can then generate (for instance) a gif through gif(anim, \"my_name.gif\", fps=15).\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.plot_difference!-Tuple{Any, Any}","page":"Index","title":"WaterWaves1D.plot_difference!","text":"plot_difference!( plt, problems ; t,x,interpolation,compression,fast,surface,velocity,fourier,label )\n\nPlots in plt the difference between solutions of initial-value problems at a given time.\n\nArgument\n\npairs is a either a collection (vector, list, etc.) of elements of type Problem, or of pairs of such elements. If pairs are provided, then solutions of such problems are compared. If a collection of problems are provided, then all possible pairs are compared.\n\nKeyword arguments (all optional)\n\nt is the time. If not provided, then the last computed time is plotted.\nif a vector x is provided and if possible, the solution is interpolated to the collocation points x.\nif interpolation is provided as an integer, the solution is interpolated on as many collocation points (if true, then the value 2^3 is chosen, default is false).\nif fast = false (default is false), then the second problem is interpolated to the collocation points of the first problem.\nif compression is provided as an integer m, only one in m points are plotted (if true, then the value 2^3 is chosen, default is false).\nsurface, velocity and fourier (booleans) determine respectively whether surface deformation, η, tangential velocity, v, and the Fourier coefficients of η (in log-scale) are plotted.\nlabel defines the label(s) if provided (otherwise labels are inferred from the problems).\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.plot_difference-Tuple{Any}","page":"Index","title":"WaterWaves1D.plot_difference","text":"plot_difference( pairs; t,x, interpolation,compression, surface,velocity,fourier, label )\n\nSame as plot_difference! but generates and returns the plot.\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.plot_solution!-Tuple{Any, Any}","page":"Index","title":"WaterWaves1D.plot_solution!","text":"plot_solution!( plt; problems; t,x,interpolation,compression,surface,velocity,fourier,label )\n\nPlots in plt the solution of initial-value problems at a given time.\n\nArgument\n\nproblems is either an element or a collection (vector, list, etc.) of elements of type Problem.\n\nKeyword arguments (all optional)\n\nt is the time. If not provided, then the last computed time is plotted.\nif a vector x is provided and if possible, the solution is interpolated to the collocation points x.\nif interpolation is provided as an integer, the solution is interpolated on as many collocation points (if true, then the value 2^3 is chosen, default is false).\nif compression is provided as an integer m, only one in m points are plotted (if true, then the value 2^3 is chosen, default is false).\nsurface, velocity and fourier (booleans) determine respectively whether surface deformation, η, tangential velocity, v, and the Fourier coefficients of η (in log-scale) are plotted.\nlabel defines the label(s) if provided (otherwise labels are inferred from the problems)\n\n\n\n\n\n","category":"method"},{"location":"#WaterWaves1D.plot_solution-Tuple{Any}","page":"Index","title":"WaterWaves1D.plot_solution","text":"plot_solution( problems; t,x, interpolation,compression, surface,velocity,fourier, label )\n\nSame as plot_solution! but generates and returns the plot.\n\n\n\n\n\n","category":"method"},{"location":"example/#Example","page":"Example","title":"Example","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"In this example we shall observe the disintegration of a heap of water using the water-waves system as well as a second-order small-steepness model.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"More advanced examples can be found in the package's examples and notebooks section.","category":"page"},{"location":"example/#Set-up-the-initial-value-problem","page":"Example","title":"Set up the initial-value problem","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"First we define parameters of our problem.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using Plots\nusing WaterWaves1D\n\nparam = (\n    # Physical parameters. Variables are non-dimensionalized as in Lannes, The water waves problem, isbn:978-0-8218-9470-5\n    μ  = 1,     # shallow-water dimensionless parameter\n    ϵ  = 1/4,   # nonlinearity dimensionless parameter\n    # Numerical parameters\n    N  = 2^10,  # number of collocation points\n    L  = 10,    # half-length of the numerical tank (-L,L)\n    T  = 5,     # final time of computation\n    dt = 0.01,  # timestep\n                );","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Now we define initial data (the \"heap of water\"). The function Init may take either functions, or vectors (values at collocation points) as arguments.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"z(x) = exp.(-abs.(x).^4); # surface deformation\nv(x) = 0*exp.(-x.^2);     # zero initial velocity\ninit = Init(z,v);         # generate the initial data with correct type","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Then we build the different models to compare (see WaterWaves and WWn).","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"WW_model=WaterWaves(param) # The water waves system\nWW2_model=WWn(param;n=2,dealias=1,δ=1/10) # The quadratic model (WW2)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Finally we set up initial-value problems. Optionally, one may specify a time solver to Problem, by default the standard explicit fourth order Runge Kutta method is used.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"WW_problem=Problem(WW_model, init, param) ;\nWW2_problem=Problem(WW2_model, init, param) ;","category":"page"},{"location":"example/#Solve-the-initial-value-problem","page":"Example","title":"Solve the initial-value problem","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Solving the initial-value problems is as easy as solve!.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"solve!([WW_problem WW2_problem];verbose=false);","category":"page"},{"location":"example/#Generate-graphics","page":"Example","title":"Generate graphics","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Plot solutions at final time (plot_solution has many options).","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"plot_solution([WW_problem WW2_problem];fourier=false)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Generate an animation (plot_solution has many options).","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"anim = create_animation([WW_problem WW2_problem];fourier=false,ylims=(-0.5,1))\ngif(anim, \"assets/example.gif\", fps=15); nothing # hide","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"(Image: )","category":"page"}]
}
