<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Models · WaterWaves1D.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><script src="../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">WaterWaves1D.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../quickstart/">Quickstart</a></li><li class="is-active"><a class="tocitem" href>Models</a></li><li><a class="tocitem" href="../figures/">Graphics</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Models</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/master/docs/src/models.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Models"><a class="docs-heading-anchor" href="#Models">Models</a><a id="Models-1"></a><a class="docs-heading-anchor-permalink" href="#Models" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.Boussinesq" href="#WaterWaves1D.Boussinesq"><code>WaterWaves1D.Boussinesq</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Boussinesq(param;kwargs)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for <code>abcd</code>-Boussinesq models (with <code>b=d</code> and <code>c=0</code>). See <a href="https://doi.org/10.1007/s00332-002-0466-4">Bona, Chen, and Saut</a></p><p><strong>Argument</strong></p><p><code>param</code> is of type <code>NamedTuple</code> and must contain</p><ul><li>dimensionless parameters <code>ϵ</code> (nonlinearity) and <code>μ</code> (dispersion);</li><li>numerical parameters to construct the mesh of collocation points as <code>mesh = Mesh(param)</code>.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li>two parameters <code>a</code> (default is <code>-1/3</code>) and <code>b</code> (default is <code>+1/3</code>) which determine the model solved. You need <code>a+2*b=1/3</code> for validity as a long wave model (without surface tension).</li><li><code>ktol</code>: tolerance of the low-pass Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>dealias</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>label</code>: a label for future references (default is <code>&quot;Boussinesq&quot;</code>);</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>Boussinesq.f!</code> to be called in explicit time-integration solvers;</li><li>a function <code>Boussinesq.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>Boussinesq.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v)</code>, where<ul><li><code>η</code> is the surface deformation;</li><li><code>v</code> is the derivative of the trace of the velocity potential.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/2e6aeee31fba53265497b5c421f1e57d8e79ce49/src/models/Boussinesq.jl#L3-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.CnoidalSGN" href="#WaterWaves1D.CnoidalSGN"><code>WaterWaves1D.CnoidalSGN</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CnoidalSGN(param; P=1)</code></pre><p>Build the initial data associated with <code>CnoidalWaveSerreGreenNaghdi(param; P=1)</code>, of type <code>InitialData</code>, to be used in initial-value problems <code>Problem(model, initial::InitialData, param)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/2e6aeee31fba53265497b5c421f1e57d8e79ce49/src/initialdata/CnoidalWaveSerreGreenNaghdi.jl#L65-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.Data" href="#WaterWaves1D.Data"><code>WaterWaves1D.Data</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Data( mm :: Matrix )</code></pre><p>Data structure to store the solution of an initial-value problem along time.</p><p><code>data=Data(m)</code> is of parametric type and offers</p><ul><li><code>data.U</code>, a 1-element vector with a copy of the matrix <code>m</code>;</li><li><code>(data.datalength,data.datasize)=size(m)</code>  where <code>datalength</code> is the number of computed modes, and <code>datasize</code> the number of involved equations, typically 2.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/2e6aeee31fba53265497b5c421f1e57d8e79ce49/src/data.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.DeepQuadratic" href="#WaterWaves1D.DeepQuadratic"><code>WaterWaves1D.DeepQuadratic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DeepQuadratic(param;dealias,label)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for the quadratic deep-water model proposed by <a href="https://doi.org/10.1137/090758386">Akers and Milewski</a> and <a href="https://doi.org/10.1007/s42286-019-00005-w">Cheng, Granero-Belinchón, Shkoller and Milewski</a></p><p><strong>Arguments</strong></p><p><code>param</code> is of type <code>NamedTuple</code> and must contain</p><ul><li>the dimensionless parameters <code>ϵ</code> (nonlinearity);</li><li>numerical parameters to construct the mesh of collocation points as <code>mesh = Mesh(param)</code>.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>dealias</code>: dealiasing with <code>1/3</code> Orlicz rule if <code>true</code> or no dealiasing if <code>false</code> (by default);</li><li><code>label</code>: a label for future references (default is <code>&quot;deep quadratic&quot;</code>);</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>DeepQuadratic.f!</code> to be called in explicit time-integration solvers;</li><li>a function <code>DeepQuadratic.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>DeepQuadratic.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v)</code>, where<ul><li><code>η</code> is the surface deformation;</li><li><code>v</code> is given by <code>∂t η = - ∂x v</code>.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/2e6aeee31fba53265497b5c421f1e57d8e79ce49/src/models/DeepQuadratic.jl#L111-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.DeepQuadratic_fast" href="#WaterWaves1D.DeepQuadratic_fast"><code>WaterWaves1D.DeepQuadratic_fast</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DeepQuadratic_fast(param;dealias,label)</code></pre><p>Same as <code>DeepQuadratic</code>, but faster.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/2e6aeee31fba53265497b5c421f1e57d8e79ce49/src/models/DeepQuadratic.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.Euler" href="#WaterWaves1D.Euler"><code>WaterWaves1D.Euler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Euler(arguments;realdata)</code></pre><p>Explicit Euler solver.</p><p>Construct an object of type <code>TimeSolver</code> to be used in <code>Problem(model, initial, param; solver::TimeSolver)</code></p><p>Arguments can be either</p><ol><li>an object of type <code>AbstractModel</code>;</li><li>an <code>Array</code> of size <code>(N,m)</code> where <code>N</code> is the number of collocation points and <code>m</code> the number of data (equations solved);</li><li>a <code>Tuple</code> <code>(N,m)</code> as above;</li><li>an integer <code>N</code> and an integer <code>m</code> as above (the latter is optional, by default <code>m=2</code>).</li><li>a <code>NamedTuple</code> containing a key <code>N</code> and an integer <code>m</code> (the latter is optional, by default <code>m=2</code>).</li></ol><p>The keyword argument <code>realdata</code> is optional, and determines whether pre-allocated vectors are real- or complex-valued. By default, they are either determined by the model or the type of the array in case <code>0.</code> and <code>1.</code>, complex-valued otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/2e6aeee31fba53265497b5c421f1e57d8e79ce49/src/solvers/Euler.jl#L4-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.EulerSymp" href="#WaterWaves1D.EulerSymp"><code>WaterWaves1D.EulerSymp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EulerSymp(arguments;Niter,implicit,realdata)</code></pre><p>Symplectic Euler solver. The implicit Euler method is first used on one equation, then the explicit Euler method is used on the second one. The implicit equation is solved via Neumann iteration</p><p>Construct an object of type <code>TimeSolver</code> to be used in <code>Problem(model, initial, param; solver::TimeSolver)</code></p><p>Arguments can be either</p><ol><li>an object of type <code>AbstractModel</code>;</li><li>an <code>Array</code> of size <code>(N,2)</code> where <code>N</code> is the number of collocation points;</li><li>an integer <code>N</code> being the number of collocation points;</li><li>a <code>NamedTuple</code> containing a key <code>N</code>.</li></ol><p>The keyword argument <code>Niter</code> (optional, defaut value = 10) determines the number of steps in the Neumann iteration solver of the implicit step. The keyword argument <code>implicit</code> (optional, defaut value = 1) determines which equation is implicit (must be <code>1</code> or <code>2</code>). The keyword argument <code>realdata</code> is optional, and determines whether pre-allocated vectors are real- or complex-valued. By default, they are either determined by the model or the type of the array in case <code>0.</code> and <code>1.</code>, complex-valued otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/2e6aeee31fba53265497b5c421f1e57d8e79ce49/src/solvers/EulerSymp.jl#L4-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.Euler_naive" href="#WaterWaves1D.Euler_naive"><code>WaterWaves1D.Euler_naive</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Euler_naive()</code></pre><p>Runge-Kutta fourth order solver.</p><p>A naive version of <code>Euler</code>, without argument since no pre-allocation is performed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/2e6aeee31fba53265497b5c421f1e57d8e79ce49/src/solvers/Euler.jl#L69-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.Init" href="#WaterWaves1D.Init"><code>WaterWaves1D.Init</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Init(data ; fast, label)</code></pre><p>Generate an initial data to be used in the function <code>Problem</code>.</p><p><code>data</code> should contain either</p><ul><li>a function <code>η</code> and a function <code>v</code> (in this order)</li><li>a Namedtuple with a function <code>η</code> and a function <code>v</code></li><li>a mesh and two vectors representing η(mesh.x) and v(mesh.x) (in this order)</li><li>a mesh and a Namedtuple with a vector <code>η</code> and a vector <code>v</code> as above</li><li>an array of collocation points and two vectors representing <code>η(x)</code> and <code>v(x)</code> (in this order)</li><li>a mesh and a Namedtuple with a vector <code>η</code> and a vector <code>v</code> as above</li></ul><p>In the last four cases, an optional keyword argument <code>fast</code> can be set to <code>true</code>, (default is <code>false</code>), in which case the algorithm is faster and uses less allocations, but is less precise.</p><p>In the last two cases, the collocation points must be regularly spaced, otherwise an <code>ErrorException</code> is raised.</p><p>If the keyword <code>label::String</code> (used to display information to the output stream) is not provided, then it is set to the <code>&quot;user-defined&quot;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/2e6aeee31fba53265497b5c421f1e57d8e79ce49/src/init.jl#L2-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.IsobeKakinuma" href="#WaterWaves1D.IsobeKakinuma"><code>WaterWaves1D.IsobeKakinuma</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IsobeKakinuma(param;kwargs)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for the Isobe-Kakinuma model.</p><p><strong>Argument</strong></p><p><code>param</code> is of type <code>NamedTuple</code> (or a collection <code>NamedTuple</code>s) of and must contain</p><ul><li>dimensionless parameters <code>ϵ</code> (nonlinearity) and <code>μ</code> (dispersion);</li><li>numerical parameters to construct the mesh of collocation points as <code>mesh = Mesh(param)</code>.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>iterative</code>: solve the elliptic problem through GMRES if <code>true</code>, LU decomposition if <code>false</code> (default is <code>true</code>);</li><li><code>precond</code>: use a (left) preconditioner for GMRES if <code>true</code> (default), choose <code>precond</code> as the preconditioner if provided;</li><li><code>gtol</code>: relative tolerance of the GMRES algorithm (default is <code>1e-14</code>);</li><li><code>restart</code>: the corresponding option of the GMRES algorithm (default is <code>100</code>);</li><li><code>maxiter</code>: the corresponding option of GMRES (default is <code>nothing</code>);</li><li><code>ktol</code>: tolerance of the Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>dealias</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>label</code>: a label for future references (default is <code>&quot;Isobe-Kakinuma&quot;</code>);</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>IsobeKakinuma.f!</code> to be called in explicit time-integration solvers;</li><li>a function <code>IsobeKakinuma.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>IsobeKakinuma.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v)</code>, where<ul><li><code>η</code> is the surface deformation;</li><li><code>v</code> is the derivative of the trace of the velocity potential;</li></ul></li><li>additionally, a handy function <code>IsobeKakinuma.mapfrofull</code> which from data matrix returns the Tuple of real vectors <code>(η,v,Φ)</code>, where<ul><li><code>Φ</code> is the Vector of the basis functions <code>ϕi</code> (<code>i∈{0,...,N}</code>).</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/2e6aeee31fba53265497b5c421f1e57d8e79ce49/src/models/IsobeKakinuma.jl#L3-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.Matsuno" href="#WaterWaves1D.Matsuno"><code>WaterWaves1D.Matsuno</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Matsuno(param;dealias,label)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for the quadratic deep-water model proposed by <a href="https://doi.org/10.1103/PhysRevLett.69.609">Matsuno</a>.</p><p><strong>Arguments</strong></p><p><code>param</code> is of type <code>NamedTuple</code> and must contain</p><ul><li>the dimensionless parameters <code>ϵ</code> (nonlinearity);</li><li>numerical parameters to construct the mesh of collocation points as <code>mesh = Mesh(param)</code>.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>dealias</code>: dealiasing with <code>1/3</code> Orlicz rule if <code>true</code> or no dealiasing if <code>false</code> (by default);</li><li><code>label</code>: a label for future references (default is <code>&quot;Matsuno&quot;</code>);</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>DeepQuadratic.f!</code> to be called in explicit time-integration solvers;</li><li>a function <code>DeepQuadratic.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>DeepQuadratic.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v)</code>, where<ul><li><code>η</code> is the surface deformation;</li><li><code>v</code> is a velocity variable which is <em>not</em> the derivative of the trace of the velocity potential (if not null).</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/2e6aeee31fba53265497b5c421f1e57d8e79ce49/src/models/Matsuno.jl#L143-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.Matsuno_fast" href="#WaterWaves1D.Matsuno_fast"><code>WaterWaves1D.Matsuno_fast</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Matsuno_fast(param;dealias,label)</code></pre><p>Same as <code>Matsuno</code>, but faster.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/2e6aeee31fba53265497b5c421f1e57d8e79ce49/src/models/Matsuno.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.Mesh" href="#WaterWaves1D.Mesh"><code>WaterWaves1D.Mesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Mesh(args)</code></pre><p>Constructs a mesh of collocation points and associated Fourier modes.</p><p><strong>Arguments</strong></p><p>Can be either</p><ul><li><code>xmin</code>, <code>xmax</code>, and <code>N</code>; or</li><li><code>L</code>, <code>N</code> (same as above with <code>xmin=-L</code> and <code>xmax=L</code>); or</li><li><code>param :: NamedTuple</code>, a <code>NamedTuple</code> containing <code>N</code> and <code>L</code> or <code>xmin</code> and <code>xmax</code>, then same as above; or</li><li><code>x</code> a vector of regularly spaced collocation points`.</li></ul><p>The mesh as <code>N</code> collocation points regularly spaced between <code>xmin</code> (included) and <code>xmax</code> (excluded)</p><p><strong>Return values</strong></p><p><code>m=Mesh(args)</code> is of parametric type and offers with</p><ul><li><code>m.N</code>: number of collocation points and Fourier modes;</li><li><code>m.xmin</code>: minimum of the mesh (included in the vector of collocation points);</li><li><code>m.xmax</code>: maximum of the mesh (excluded in the vector of collocation points);</li><li><code>m.dx</code>: distance between two collocation points;</li><li><code>m.x</code>: the vector of collocation points;</li><li><code>m.kmin</code>: minimum of Fourier modes (included in the vector of Fourier modes);</li><li><code>m.kmax</code>: maximum of Fourier modes (included in the vector of Fourier modes);;</li><li><code>m.dk</code>: distance between two Fourier modes;</li><li><code>m.k</code>: the vector of Fourier modes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/2e6aeee31fba53265497b5c421f1e57d8e79ce49/src/mesh.jl#L3-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.NonHydrostatic" href="#WaterWaves1D.NonHydrostatic"><code>WaterWaves1D.NonHydrostatic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NonHydrostatic(param;kwargs)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for the &quot;Non-hydrostatic&quot; model proposed by <a href="https://doi.org/10.3934/dcdsb.2015.20.961">Bristeau, Mangeney, Sainte-Marie and Seguin</a></p><p><strong>Argument</strong></p><p><code>param</code> is of type <code>NamedTuple</code> and must contain</p><ul><li>dimensionless parameters <code>ϵ</code> (nonlinearity) and <code>μ</code> (dispersion);</li><li>numerical parameters to construct the mesh of collocation points as <code>mesh = Mesh(param)</code>.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>iterative</code>: solve the elliptic problem through GMRES if <code>true</code>, LU decomposition if <code>false</code> (default is <code>true</code>);</li><li><code>precond</code>: use a (left) preconditioner for GMRES if <code>true</code> (default), choose <code>precond</code> as the preconditioner if provided;</li><li><code>gtol</code>: relative tolerance of the GMRES algorithm (default is <code>1e-14</code>);</li><li><code>restart</code>: the corresponding option of the GMRES algorithm (default is <code>100</code>);</li><li><code>maxiter</code>: the corresponding option of GMRES (default is <code>nothing</code>);</li><li><code>ktol</code>: tolerance of the Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>dealias</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>label</code>: a label for future references (default is <code>&quot;non-hydrostatic&quot;</code>);</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>NonHydrostatic.f!</code> to be called in explicit time-integration solvers;</li><li>a function <code>NonHydrostatic.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>NonHydrostatic.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v)</code>, where<ul><li><code>η</code> is the surface deformation;</li><li><code>v</code> is the derivative of the trace of the velocity potential;</li></ul></li><li>additionally, a handy function <code>NonHydrostatic.mapfrofull</code> which from data matrix returns the Tuple of real vectors <code>(η,v,u)</code>, where<ul><li><code>u</code> corresponds to the layer-averaged velocity.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/2e6aeee31fba53265497b5c421f1e57d8e79ce49/src/models/NonHydrostatic.jl#L3-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.Problem" href="#WaterWaves1D.Problem"><code>WaterWaves1D.Problem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Problem( model, initial, param ; solver, label)</code></pre><p>Build an initial-value problem which can then be solved (i.e. integrated in time) through <code>solve!( problem )</code></p><p><strong>Arguments</strong></p><ul><li><code>model   :: AbstractModel</code>,  the system of equation solved.</li></ul><p>May be built, e.g., by <code>WaterWaves(param)</code>;</p><ul><li><code>initial :: InitialData</code>, the initial data.</li></ul><p>May be buit, e.g., by <code>Init(η,v)</code> where <code>η</code> is the surface deformation and <code>v</code> the derivative of the trace of the velocity potential at the surface;</p><ul><li><code>param   :: NamedTuple</code>, must contain values for<ul><li><code>N</code>, the number of collocation points of the spatial grid</li><li><code>L</code>, the half-length of the spatial grid</li><li><code>T</code>, the final time of integration</li><li><code>dt</code>, the timestep</li><li>additionally, it may contain <code>Ns</code> the number of computed data or <code>ns</code> for storing data every <code>ns</code> computation steps (by default, every computed data is stored).</li></ul></li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>solver :: TimeSolver</code>, the solver for time integration (default is explicit Runge-Kutta fourth order solver).</li></ul><p>May be built, e.g., by <code>RK4(model)</code> or <code>RK4_naive()</code>.</p><ul><li>label   :: String <code>is used in future references (e.g.</code>plot_solution`).</li><li>Information are not printed if <code>verbose = false</code> (default is <code>true</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/2e6aeee31fba53265497b5c421f1e57d8e79ce49/src/problem.jl#L3-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.RK4" href="#WaterWaves1D.RK4"><code>WaterWaves1D.RK4</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RK4(arguments;realdata)</code></pre><p>Explicit Runge-Kutta fourth order solver.</p><p>Construct an object of type <code>TimeSolver</code> to be used in <code>Problem(model, initial, param; solver::TimeSolver)</code></p><p>Arguments can be either</p><ol><li>an object of type <code>AbstractModel</code>;</li><li>an <code>Array</code> of size <code>(N,m)</code> where <code>N</code> is the number of collocation points and <code>m</code> the number of data (equations solved);</li><li>a <code>Tuple</code> <code>(N,m)</code> as above;</li><li>an integer <code>N</code> and an integer <code>m</code> as above (the latter is optional, by default <code>m=2</code>).</li><li>a <code>NamedTuple</code> containing a key <code>N</code> and an integer <code>m</code> (the latter is optional, by default <code>m=2</code>).</li></ol><p>The keyword argument <code>realdata</code> is optional, and determines whether pre-allocated vectors are real- or complex-valued. By default, they are either determined by the model in case <code>1.</code>, complex-valued otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/2e6aeee31fba53265497b5c421f1e57d8e79ce49/src/solvers/RK4.jl#L4-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.RK4_naive" href="#WaterWaves1D.RK4_naive"><code>WaterWaves1D.RK4_naive</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RK4_naive()</code></pre><p>Runge-Kutta fourth order solver.</p><p>A naive version of <code>RK4</code>, without argument since no pre-allocation is performed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/2e6aeee31fba53265497b5c421f1e57d8e79ce49/src/solvers/RK4.jl#L86-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.Random" href="#WaterWaves1D.Random"><code>WaterWaves1D.Random</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Random(mesh::Mesh;args)</code></pre><p>Randomly generated initial data, based on provided (optional arguments) :</p><ul><li><code>L</code> is the typical wavelength (default is <code>L=1</code>),</li><li><code>s</code> is the (real) Sobolev index regularity (default is <code>s=∞</code>),</li><li><code>λ</code> is the length of spatial localization (default is <code>λ=∞</code>, no localization),</li><li><code>a</code> is the couple of amplitudes of the surface deformation, and velocity (default is <code>a=(1,1)</code>).</li></ul><p>Return an initial data <code>init::InitialData</code>,  to be used in initial-value problems <code>Problem(model, init, param)</code>, with <code>init.η</code> and <code>init.v</code> two samples of <code>random(x;L,s,λ)</code>, where <code>x</code> is the set of collocation points generated by <code>Mesh(param)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/2e6aeee31fba53265497b5c421f1e57d8e79ce49/src/initialdata/Random.jl#L40-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.SerreGreenNaghdi" href="#WaterWaves1D.SerreGreenNaghdi"><code>WaterWaves1D.SerreGreenNaghdi</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SerreGreenNaghdi(param;kwargs)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for the Serre-Green-Naghdi model</p><p><strong>Argument</strong></p><p><code>param</code> is of type <code>NamedTuple</code> and must contain</p><ul><li>dimensionless parameters <code>ϵ</code> (nonlinearity) and <code>μ</code> (dispersion);</li><li>numerical parameters to construct the mesh of collocation points as <code>mesh = Mesh(param)</code>.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>iterative</code>: solve the elliptic problem through GMRES if <code>true</code>, LU decomposition if <code>false</code> (default is <code>true</code>);</li><li><code>precond</code>: use a (left) preconditioner for GMRES if <code>true</code> (default), choose <code>precond</code> as the preconditioner if provided;</li><li><code>gtol</code>: relative tolerance of the GMRES algorithm (default is <code>1e-14</code>);</li><li><code>restart</code>: the corresponding option of the GMRES algorithm (default is <code>100</code>);</li><li><code>maxiter</code>: the corresponding option of GMRES (default is <code>nothing</code>);</li><li><code>ktol</code>: tolerance of the Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>dealias</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>label</code>: a label for future references (default is <code>&quot;Green-Naghdi&quot;</code>);</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>SerreGreenNaghdi.f!</code> to be called in explicit time-integration solvers;</li><li>a function <code>SerreGreenNaghdi.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>SerreGreenNaghdi.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v)</code>, where<ul><li><code>η</code> is the surface deformation;</li><li><code>v</code> is the derivative of the trace of the velocity potential;</li></ul></li><li>additionally, a handy function <code>SerreGreenNaghdi.mapfrofull</code> which from data matrix returns the Tuple of real vectors <code>(η,v,u)</code>, where<ul><li><code>u</code> corresponds to the layer-averaged velocity.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/2e6aeee31fba53265497b5c421f1e57d8e79ce49/src/models/SerreGreenNaghdi.jl#L3-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.SolitarySGN" href="#WaterWaves1D.SolitarySGN"><code>WaterWaves1D.SolitarySGN</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SolitarySGN(param; x₀=0)</code></pre><p>Build the initial data associated with <code>SolitaryWaveSerreGreenNaghdi(param; x₀=0)</code>, of type <code>InitialData</code>, to be used in initial-value problems <code>Problem(model, initial::InitialData, param)</code>.</p><hr/><pre><code class="nohighlight hljs">SolitarySGN(c; ϵ=1,μ=1,x₀=0,N=2^12)</code></pre><p>Build the initial data with velocity <code>c</code>, center <code>x₀</code>, dimensionless parameters <code>ϵ</code> and <code>μ</code>, and number of collocation points <code>N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/2e6aeee31fba53265497b5c421f1e57d8e79ce49/src/initialdata/SolitaryWaveSerreGreenNaghdi.jl#L53-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.SolitaryWB" href="#WaterWaves1D.SolitaryWB"><code>WaterWaves1D.SolitaryWB</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SolitaryWB(param; kwargs)</code></pre><p>Build the initial data associated with <code>SolitaryWaveWhithamBoussinesq(param; kwargs)</code>, of type <code>InitialData</code>, to be used in initial-value problems <code>Problem(model, initial::InitialData, param)</code>.</p><hr/><pre><code class="nohighlight hljs">SolitaryWB(c; ϵ=1,μ=1,N=2^12,kwargs)</code></pre><p>Build the initial data with velocity <code>c</code>, dimensionless parameters <code>ϵ</code> and <code>μ</code>, and number of collocation points <code>N</code>, and <code>kwargs</code> the other (optional) keyword arguments as above.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/2e6aeee31fba53265497b5c421f1e57d8e79ce49/src/initialdata/SolitaryWaveWhithamBoussinesq.jl#L170-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.SolitaryWGN" href="#WaterWaves1D.SolitaryWGN"><code>WaterWaves1D.SolitaryWGN</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SolitaryWGN(param; kwargs)</code></pre><p>Build the initial data associated with <code>SolitaryWaveWhithamGreenNaghdi(param; kwargs)</code>, of type <code>InitialData</code>, to be used in initial-value problems <code>Problem(model, initial::InitialData, param)</code>.</p><hr/><pre><code class="nohighlight hljs">SolitaryWGN(c; ϵ=1,μ=1,N=2^12,kwargs)</code></pre><p>Build the initial data with velocity <code>c</code>, dimensionless parameters <code>ϵ</code> and <code>μ</code>, and number of collocation points <code>N</code>, and <code>kwargs</code> the other (optional) keyword arguments as above.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/2e6aeee31fba53265497b5c421f1e57d8e79ce49/src/initialdata/SolitaryWaveWhithamGreenNaghdi.jl#L290-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.SolitaryWhitham" href="#WaterWaves1D.SolitaryWhitham"><code>WaterWaves1D.SolitaryWhitham</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SolitaryWhitham(param; kwargs)</code></pre><p>Build the initial data associated with <code>SolitaryWaveWhitham(param; kwargs)</code>, of type <code>InitialData</code>, to be used in initial-value problems <code>Problem(model, initial::InitialData, param)</code>.</p><hr/><pre><code class="nohighlight hljs">SolitaryWhitham(c; ϵ=1,μ=1,N=2^12,kwargs)</code></pre><p>Build the initial data with velocity <code>c</code>, dimensionless parameters <code>ϵ</code> and <code>μ</code>, and number of collocation points <code>N</code>, and <code>kwargs</code> the other (optional) keyword arguments as above.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/2e6aeee31fba53265497b5c421f1e57d8e79ce49/src/initialdata/SolitaryWaveWhitham.jl#L150-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.SquareRootDepth" href="#WaterWaves1D.SquareRootDepth"><code>WaterWaves1D.SquareRootDepth</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SquareRootDepth(param;kwargs)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for the &quot;√D&quot; model proposed by <a href="https://doi.org/10.1098/rspa.2010.0124">Cotter, Holm and Percival</a></p><p><strong>Argument</strong></p><p><code>param</code> is of type <code>NamedTuple</code> and must contain</p><ul><li>dimensionless parameters <code>ϵ</code> (nonlinearity) and <code>μ</code> (dispersion);</li><li>numerical parameters to construct the mesh of collocation points as <code>mesh = Mesh(param)</code>.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>iterative</code>: solve the elliptic problem through GMRES if <code>true</code>, LU decomposition if <code>false</code> (default is <code>true</code>);</li><li><code>precond</code>: use a (left) preconditioner for GMRES if <code>true</code> (default), choose <code>precond</code> as the preconditioner if provided;</li><li><code>gtol</code>: relative tolerance of the GMRES algorithm (default is <code>1e-14</code>);</li><li><code>restart</code>: the corresponding option of the GMRES algorithm (default is <code>100</code>);</li><li><code>maxiter</code>: the corresponding option of GMRES (default is <code>nothing</code>);</li><li><code>ktol</code>: tolerance of the Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>dealias</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>label</code>: a label for future references (default is <code>&quot;square-root depth&quot;</code>);</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>SquareRootDepth.f!</code> to be called in explicit time-integration solvers;</li><li>a function <code>SquareRootDepth.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>SquareRootDepth.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v)</code>, where<ul><li><code>η</code> is the surface deformation;</li><li><code>v</code> is the derivative of the trace of the velocity potential;</li></ul></li><li>additionally, a handy function <code>SquareRootDepth.mapfrofull</code> which from data matrix returns the Tuple of real vectors <code>(η,v,u)</code>, where<ul><li><code>u</code> corresponds to the layer-averaged velocity.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/2e6aeee31fba53265497b5c421f1e57d8e79ce49/src/models/SquareRootDepth.jl#L3-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.Times" href="#WaterWaves1D.Times"><code>WaterWaves1D.Times</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Times(param; ns, Ns)</code></pre><p>Constructs a mesh of times, to be used in initial-value problems (see <code>Problem</code>).</p><p><strong>Arguments</strong></p><p><code>param</code> is either</p><ul><li><code>dt,T</code> with <code>dt</code> the timestep and <code>T</code> the final time of comuptation; or</li><li>a <code>NamedTuple</code> containing <code>dt</code> and <code>T</code></li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>ns</code>  : data are stored every <code>ns</code> computations (optional, default = 1).</li><li><code>Ns</code>  : <code>Ns</code> data (in addition to the initial datum) are stored (optional, by default `floor( tfin/dt)).</li></ul><p>If both <code>Ns</code> and <code>ns</code> are given, <code>Ns</code> overrules <code>ns</code>.</p><p><strong>Return values</strong></p><p><code>t=Times(args)</code> is of parametric type and offers</p><ul><li><code>t.Nc</code>: number of computed times (including initial datum);</li><li><code>t.Ns</code>: number of stored times (including initial datum);</li><li><code>t.ns</code>: number of computed times between two stored times;</li><li><code>t.tfin</code>: the final time;</li><li><code>t.dt</code>: the timestep;</li><li><code>t.tc</code> : the vector of computed times;</li><li><code>t.ts</code>: the vector of stored times.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/2e6aeee31fba53265497b5c421f1e57d8e79ce49/src/times.jl#L2-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.WWn" href="#WaterWaves1D.WWn"><code>WaterWaves1D.WWn</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WWn(param;kwargs)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for the water waves expansion proposed by Dommermuth and Yue (doi:10.1017/s002211208700288x), West et al. (doi:10.1029/jc092ic11p11803), Craig and Sulem (doi:10.1006/jcph.1993.1164) (see also the account by Choi : Fifth-order nonlinear spectral model for surface gravity waves: From pseudo-spectral to spectral formulations, RIMS Kokyuroku, 2019) with the &quot;rectification&quot; method proposed by Duchêne and Melinand.</p><p><strong>Argument</strong></p><p><code>param</code> is of type <code>NamedTuple</code> and must contain</p><ul><li>dimensionless parameters <code>ϵ</code> (nonlinearity) and <code>μ</code> (dispersion);</li><li>numerical parameters to construct the mesh of collocation points as <code>mesh = Mesh(param)</code></li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>ν</code>: shallow/deep water multiplication factor. By default, <code>ν=1</code> if <code>μ≦1</code> and <code>ν=1/√μ</code> otherwise. Set the infinite-layer case if <code>ν=0</code> (or <code>μ=Inf</code>).</li><li><code>IL</code>: Set the infinite-layer case if <code>IL=true</code> (or <code>μ=Inf</code>, or <code>ν=0</code>), in which case <code>ϵ</code> is the steepness parameter. Default is <code>false</code>.</li><li><code>n :: Int</code>: the order of the expansion; linear system if <code>1</code>, quadratic if <code>2</code>, cubic if <code>3</code>, quartic if <code>4</code> (default and other values yield <code>2</code>);</li><li><code>δ</code> and <code>m</code>: parameters of the rectifier operator, set as <code>k-&gt;min(1,|δ*k|^m)</code> or <code>k-&gt;min(1,|δ*k|^m[1]*exp(1-|δ*k|^m[2]))</code> if <code>m</code> is a couple</li></ul><p>(by default is <code>δ=0</code>, i.e. no regularization and <code>m=-1</code>. Notice <code>m=-Inf</code> and <code>δ&gt;0</code> yields a cut-off filter);</p><ul><li><code>ktol</code>: tolerance of the low-pass Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>dealias</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>label</code>: a label for future references (default is <code>&quot;WWn&quot;</code> with <code>n</code> the order of the expansion);</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>WWn.f!</code> to be called in explicit time-integration solvers (also <code>WWn.f1!</code> and <code>WWn.f2!</code> for the symplectic Euler solver);</li><li>a function <code>WWn.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>WWn.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v)</code>, where<ul><li><code>η</code> is the surface deformation;</li><li><code>v</code> is the derivative of the trace of the velocity potential.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/2e6aeee31fba53265497b5c421f1e57d8e79ce49/src/models/WWn.jl#L3-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.WaterWaves" href="#WaterWaves1D.WaterWaves"><code>WaterWaves1D.WaterWaves</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WaterWaves(param; kwargs)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for the water waves system (via conformal mapping, see <a href="https://doi.org/10.1016/S0997-7546(02)01189-5">Zakharov, Dyachenko and Vasilyev</a>).</p><p><strong>Argument</strong></p><p><code>param</code> is of type <code>NamedTuple</code> and must contain</p><ul><li>dimensionless parameters <code>ϵ</code> (nonlinearity) and <code>μ</code> (dispersion);</li><li>numerical parameters to construct the mesh of collocation points as <code>mesh = Mesh(param)</code>.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>ν</code>: shallow/deep water multiplication factor (see <a href="https://bookstore.ams.org/surv-188">Lannes, The water waves problem</a>). By default, <code>ν=1</code> if <code>μ≦1</code> and <code>ν=1/√μ</code> otherwise.</li><li><code>IL</code>: Set the infinite-layer case if <code>IL=true</code> (or <code>μ=Inf</code>, or <code>ν=0</code>), in which case <code>ϵ</code> is the steepness parameter. Default is <code>false</code>.</li><li><code>method ∈ {1,2,3}</code>: method used to initialize the conformal mapping, as a fix-point problem <code>F(u)=u</code><ul><li>if <code>method == 1</code>, use standard contraction fix-point iteration;</li><li>if <code>method == 2</code>, use Newton algorithm with GMRES iterative solver to invert the Jacobian;</li><li>if <code>method == 3</code>, use Newton algorithm with direct solver to invert the Jacobian;</li></ul></li><li><code>tol</code>: (relative) tolerance of the fix-point algorithm (default is <code>1e-16</code>);</li><li><code>maxiter</code>: the maximal number of iteration in the fix-point algorithm (default is <code>100</code>);</li><li><code>ktol</code>: tolerance of the low-pass Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>dealias</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>label</code>: a label for future references (default is <code>&quot;water waves&quot;</code>);</li><li><code>verbose</code>: prints information if <code>true</code> (default is <code>true</code>).</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>WaterWaves.f!</code> to be called in the explicit time-integration solver (also <code>WaterWaves.f1!</code> and <code>WaterWaves.f2!</code> for the symplectic Euler solver);</li><li>a function <code>WaterWaves.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>WaterWaves.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(x,η,v)</code>, where<ul><li><code>x</code> is a vector of collocation points (non-regularly spaced);</li><li><code>η</code> is the surface deformation at points <code>x</code>;</li><li><code>v</code> is the derivative of the trace of the velocity potential at points <code>x</code>.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/2e6aeee31fba53265497b5c421f1e57d8e79ce49/src/models/WaterWaves.jl#L3-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.WhithamBoussinesq" href="#WaterWaves1D.WhithamBoussinesq"><code>WaterWaves1D.WhithamBoussinesq</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WhithamBoussinesq(param;kwargs)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for a Boussinesq-type model with full-dispersion property.</p><p><strong>Argument</strong></p><p><code>param</code> is of type <code>NamedTuple</code> and must contain</p><ul><li>dimensionless parameters <code>ϵ</code> (nonlinearity) and <code>μ</code> (dispersion);</li><li>numerical parameters to construct the mesh of collocation points as <code>mesh = Mesh(param)</code></li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>Boussinesq</code>: if <code>true</code> (default is <code>false</code>), compute the standard Boussinesq system instead (see <code>Boussinesq(param;kwargs)</code>);</li><li>a parameter <code>α</code> which determines the model solved:<ul><li>If <code>α = 1</code> (default), then the model has been introduced in <a href="https://doi.org/10.1016/j.apnum.2018.09.016">Dinvay, Dutykh and Kalisch</a>;</li><li>If <code>α = 1/2</code>, then the model is a quasilinear version;</li><li>If <code>α &lt; 1/2</code>, then expect instabilities stemming from ill-posedness of the model.</li></ul></li><li><code>ktol</code>: tolerance of the low-pass Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>dealias</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>label</code>: a label for future references (default is <code>&quot;Whitham-Boussinesq&quot;</code>);</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>WhithamBoussinesq.f!</code> to be called in explicit time-integration solvers;</li><li>a function <code>WhithamBoussinesq.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed.</li><li>a function <code>WhithamBoussinesq.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v)</code>, where<ul><li><code>η</code> is the surface deformation;</li><li><code>v</code> is the derivative of the trace of the velocity potential.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/2e6aeee31fba53265497b5c421f1e57d8e79ce49/src/models/WhithamBoussinesq.jl#L3-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.WhithamGreenNaghdi" href="#WaterWaves1D.WhithamGreenNaghdi"><code>WaterWaves1D.WhithamGreenNaghdi</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WhithamGreenNaghdi(param;kwargs)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for the fully dispersive Green-Naghdi model proposed by <a href="https://doi.org/10.1137/130947064">Duchêne, Israwi and Talhouk</a>.</p><p><strong>Argument</strong></p><p><code>param</code> is of type <code>NamedTuple</code> and must contain</p><ul><li>dimensionless parameters <code>ϵ</code> (nonlinearity) and <code>μ</code> (dispersion);</li><li>numerical parameters to construct the mesh of collocation points as <code>mesh = Mesh(param)</code>.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>SGN</code>: if <code>true</code> (default is <code>false</code>), compute the Serre-Green-Naghdi (SGN) instead of Whitham-Green-Naghdi (WGN) system (see <code>SerreGreenNaghdi(param;kwargs)</code>);</li><li><code>iterative</code>: solve the elliptic problem through GMRES if <code>true</code>, LU decomposition if <code>false</code> (default is <code>true</code>);</li><li><code>precond</code>: use a (left) preconditioner for GMRES if <code>true</code> (default), choose <code>precond</code> as the preconditioner if provided;</li><li><code>gtol</code>: relative tolerance of the GMRES algorithm (default is <code>1e-14</code>);</li><li><code>restart</code>: the corresponding option of the GMRES algorithm (default is <code>100</code>);</li><li><code>maxiter</code>: the corresponding option of GMRES (default is <code>nothing</code>);</li><li><code>ktol</code>: tolerance of the Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>dealias</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>label</code>: a label for future references (default is <code>&quot;Whitham-Green-Naghdi&quot;</code>);</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>WhithamGreenNaghdi.f!</code> to be called in explicit time-integration solvers;</li><li>a function <code>WhithamGreenNaghdi.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>WhithamGreenNaghdi.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v)</code>, where<ul><li><code>η</code> is the surface deformation;</li><li><code>v</code> is the derivative of the trace of the velocity potential;</li></ul></li><li>additionally, a handy function <code>WhithamGreenNaghdi.mapfrofull</code> which from data matrix returns the Tuple of real vectors <code>(η,v,u)</code>, where<ul><li><code>u</code> corresponds to the layer-averaged velocity.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/2e6aeee31fba53265497b5c421f1e57d8e79ce49/src/models/WhithamGreenNaghdi.jl#L3-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.modifiedMatsuno" href="#WaterWaves1D.modifiedMatsuno"><code>WaterWaves1D.modifiedMatsuno</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">modifiedMatsuno(param;kwargs)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for the modified Matsuno model</p><p><strong>Argument</strong></p><p><code>param</code> is of type <code>NamedTuple</code> and must contain</p><ul><li>dimensionless parameters <code>ϵ</code> (nonlinearity) and <code>μ</code> (dispersion);</li><li>numerical parameters to construct the mesh of collocation points as <code>mesh = Mesh(param)</code></li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>ν</code>: shallow/deep water multiplication factor. By default, <code>ν=1</code> if <code>μ≦1</code> and <code>ν=1/√μ</code> otherwise. Set the infinite-layer case if <code>ν=0</code> (or <code>μ=Inf</code>).</li><li><code>IL</code>: Set the infinite-layer case if <code>IL=true</code> (or <code>μ=Inf</code>, or <code>ν=0</code>), in which case <code>ϵ</code> is the steepness parameter. Default is <code>false</code>.</li><li><code>ktol</code>: tolerance of the low-pass Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>dealias</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>label</code>: a label for future references (default is <code>&quot;modified Matsuno&quot;</code>);</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>modifiedMatsuno.f!</code> to be called in explicit time-integration solvers;</li><li>a function <code>modifiedMatsuno.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>modifiedMatsuno.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v)</code>, where<ul><li><code>η</code> is the surface deformation;</li><li><code>v</code> is the derivative of the trace of the velocity potential.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/2e6aeee31fba53265497b5c421f1e57d8e79ce49/src/models/modifiedMatsuno.jl#L3-L29">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quickstart/">« Quickstart</a><a class="docs-footer-nextpage" href="../figures/">Graphics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Thursday 3 February 2022 16:58">Thursday 3 February 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
