<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documentation · WaterWaves1D.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><script src="../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="quickstart/">WaterWaves1D.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="quickstart/">Quickstart</a></li><li class="is-active"><a class="tocitem" href>Documentation</a></li><li><a class="tocitem" href="basics/">Code basics</a></li><li><a class="tocitem" href="contents/">Contents</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="WaterWaves1D.jl"><a class="docs-heading-anchor" href="#WaterWaves1D.jl">WaterWaves1D.jl</a><a id="WaterWaves1D.jl-1"></a><a class="docs-heading-anchor-permalink" href="#WaterWaves1D.jl" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.Boussinesq" href="#WaterWaves1D.Boussinesq"><code>WaterWaves1D.Boussinesq</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Boussinesq(param;kwargs)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for <code>abcd</code>-Boussinesq models (with <code>b=d</code> and <code>c=0</code>). See <a href="https://doi.org/10.1007/s00332-002-0466-4">Bona, Chen, and Saut</a></p><p><strong>Argument</strong></p><p><code>param</code> is of type <code>NamedTuple</code> and must contain</p><ul><li>dimensionless parameters <code>ϵ</code> (nonlinearity) and <code>μ</code> (dispersion);</li><li>numerical parameters to construct the mesh of collocation points as <code>mesh = Mesh(param)</code>.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li>two parameters <code>a</code> (default is <code>-1/3</code>) and <code>b</code> (default is <code>+1/3</code>) which determine the model solved. You need <code>a+2*b=1/3</code> for validity as a long wave model (without surface tension).</li><li><code>ktol</code>: tolerance of the low-pass Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>dealias</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>label</code>: a label for future references (default is <code>&quot;Boussinesq&quot;</code>);</li><li><code>verbose</code>: prints information if <code>true</code> (default is <code>true</code>).</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>Boussinesq.f!</code> to be called in explicit time-integration solvers;</li><li>a function <code>Boussinesq.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>Boussinesq.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v)</code>, where<ul><li><code>η</code> is the surface deformation;</li><li><code>v</code> is the derivative of the trace of the velocity potential.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/models/Boussinesq.jl#L3-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.Data" href="#WaterWaves1D.Data"><code>WaterWaves1D.Data</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Data( mm :: Matrix )</code></pre><p>Data structure to store the solution of an initial-value problem along time.</p><p><code>data=Data(m)</code> is of parametric type and offers</p><ul><li><code>data.U</code>, a 1-element vector with a copy of the matrix <code>m</code>;</li><li><code>(data.datalength,data.datasize)=size(m)</code>  where <code>datalength</code> is the number of computed modes, and <code>datasize</code> the number of involved equations, typically 2.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/data.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.DeepQuadratic" href="#WaterWaves1D.DeepQuadratic"><code>WaterWaves1D.DeepQuadratic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DeepQuadratic(param;dealias,label,verbose)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for the quadratic deep-water model proposed by <a href="https://doi.org/10.1137/090758386">Akers and Milewski</a> and <a href="https://doi.org/10.1007/s42286-019-00005-w">Cheng, Granero-Belinchón, Shkoller and Milewski</a></p><p><strong>Arguments</strong></p><p><code>param</code> is of type <code>NamedTuple</code> and must contain</p><ul><li>the dimensionless parameters <code>ϵ</code> (nonlinearity);</li><li>numerical parameters to construct the mesh of collocation points as <code>mesh = Mesh(param)</code>.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>dealias</code>: dealiasing with <code>1/3</code> Orlicz rule if <code>true</code> or no dealiasing if <code>false</code> (by default);</li><li><code>label</code>: a label for future references (default is <code>&quot;deep quadratic&quot;</code>);</li><li><code>verbose</code>: prints information if <code>true</code> (default is <code>true</code>).</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>DeepQuadratic.f!</code> to be called in explicit time-integration solvers;</li><li>a function <code>DeepQuadratic.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>DeepQuadratic.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v)</code>, where<ul><li><code>η</code> is the surface deformation;</li><li><code>v</code> is given by <code>∂t η = - ∂x v</code>.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/models/DeepQuadratic.jl#L111-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.DeepQuadratic_fast" href="#WaterWaves1D.DeepQuadratic_fast"><code>WaterWaves1D.DeepQuadratic_fast</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DeepQuadratic_fast(param;dealias,label,verbose)</code></pre><p>Same as <code>DeepQuadratic</code>, but faster.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/models/DeepQuadratic.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.Euler" href="#WaterWaves1D.Euler"><code>WaterWaves1D.Euler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Euler(arguments;realdata)</code></pre><p>Explicit Euler solver.</p><p>Construct an object of type <code>TimeSolver</code> to be used in <code>Problem(model, initial, param; solver::TimeSolver)</code></p><p>Arguments can be either</p><ol><li>an object of type <code>AbstractModel</code>;</li><li>an <code>Array</code> of size <code>(N,m)</code> where <code>N</code> is the number of collocation points and <code>m</code> the number of data (equations solved);</li><li>a <code>Tuple</code> <code>(N,m)</code> as above;</li><li>an integer <code>N</code> and an integer <code>m</code> as above (the latter is optional, by default <code>m=2</code>).</li><li>a <code>NamedTuple</code> containing a key <code>N</code> and an integer <code>m</code> (the latter is optional, by default <code>m=2</code>).</li></ol><p>The keyword argument <code>realdata</code> is optional, and determines whether pre-allocated vectors are real- or complex-valued. By default, they are either determined by the model or the type of the array in case <code>0.</code> and <code>1.</code>, complex-valued otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/solvers/Euler.jl#L4-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.EulerSymp" href="#WaterWaves1D.EulerSymp"><code>WaterWaves1D.EulerSymp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EulerSymp(arguments;Niter,implicit,realdata)</code></pre><p>Symplectic Euler solver. The implicit Euler method is first used on one equation, then the explicit Euler method is used on the second one. The implicit equation is solved via Neumann iteration</p><p>Construct an object of type <code>TimeSolver</code> to be used in <code>Problem(model, initial, param; solver::TimeSolver)</code></p><p>Arguments can be either</p><ol><li>an object of type <code>AbstractModel</code>;</li><li>an <code>Array</code> of size <code>(N,2)</code> where <code>N</code> is the number of collocation points;</li><li>an integer <code>N</code> being the number of collocation points;</li><li>a <code>NamedTuple</code> containing a key <code>N</code>.</li></ol><p>The keyword argument <code>Niter</code> (optional, defaut value = 10) determines the number of steps in the Neumann iteration solver of the implicit step. The keyword argument <code>implicit</code> (optional, defaut value = 1) determines which equation is implicit (must be <code>1</code> or <code>2</code>). The keyword argument <code>realdata</code> is optional, and determines whether pre-allocated vectors are real- or complex-valued. By default, they are either determined by the model or the type of the array in case <code>0.</code> and <code>1.</code>, complex-valued otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/solvers/EulerSymp.jl#L4-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.Euler_naive" href="#WaterWaves1D.Euler_naive"><code>WaterWaves1D.Euler_naive</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Euler_naive()</code></pre><p>Runge-Kutta fourth order solver.</p><p>A naive version of <code>Euler</code>, without argument since no pre-allocation is performed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/solvers/Euler.jl#L68-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.Init" href="#WaterWaves1D.Init"><code>WaterWaves1D.Init</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Init(data ; fast=false)</code></pre><p>Generate an initial data to be used in the function <code>Problem</code>.</p><p><code>data</code> should contain either</p><ul><li>a function <code>η</code> and a function <code>v</code> (in this order)</li><li>a Namedtuple with a function <code>η</code> and a function <code>v</code></li><li>a mesh and two vectors representing η(mesh.x) and v(mesh.x) (in this order)</li><li>a mesh and a Namedtuple with a vector <code>η</code> and a vector <code>v</code> as above</li><li>an array of collocation points and two vectors representing <code>η(x)</code> and <code>v(x)</code> (in this order)</li><li>a mesh and a Namedtuple with a vector <code>η</code> and a vector <code>v</code> as above</li></ul><p>In the last four cases, an optional keyword argument <code>fast</code> can be set to <code>true</code>, (default is <code>false</code>), in which case the algorithm is faster and uses less allocations, but is less precise.</p><p>In the last two cases, the collocation points must be regularly spaced, otherwise an <code>ErrorException</code> is raised.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/init.jl#L2-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.IsobeKakinuma" href="#WaterWaves1D.IsobeKakinuma"><code>WaterWaves1D.IsobeKakinuma</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IsobeKakinuma(param;kwargs)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for the Isobe-Kakinuma model.</p><p><strong>Argument</strong></p><p><code>param</code> is of type <code>NamedTuple</code> (or a collection <code>NamedTuple</code>s) of and must contain</p><ul><li>dimensionless parameters <code>ϵ</code> (nonlinearity) and <code>μ</code> (dispersion);</li><li>numerical parameters to construct the mesh of collocation points as <code>mesh = Mesh(param)</code>.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>iterative</code>: solve the elliptic problem through GMRES if <code>true</code>, LU decomposition if <code>false</code> (default is <code>true</code>);</li><li><code>precond</code>: use a (left) preconditioner for GMRES if <code>true</code> (default), choose <code>precond</code> as the preconditioner if provided;</li><li><code>gtol</code>: relative tolerance of the GMRES algorithm (default is <code>1e-14</code>);</li><li><code>restart</code>: the corresponding option of the GMRES algorithm (default is <code>100</code>);</li><li><code>maxiter</code>: the corresponding option of GMRES (default is <code>nothing</code>);</li><li><code>ktol</code>: tolerance of the Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>dealias</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>label</code>: a label for future references (default is <code>&quot;Isobe-Kakinuma&quot;</code>);</li><li><code>verbose</code>: prints information if <code>true</code> (default is <code>true</code>).</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>IsobeKakinuma.f!</code> to be called in explicit time-integration solvers;</li><li>a function <code>IsobeKakinuma.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>IsobeKakinuma.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v)</code>, where<ul><li><code>η</code> is the surface deformation;</li><li><code>v</code> is the derivative of the trace of the velocity potential;</li></ul></li><li>additionally, a handy function <code>IsobeKakinuma.mapfrofull</code> which from data matrix returns the Tuple of real vectors <code>(η,v,Φ)</code>, where<ul><li><code>Φ</code> is the Vector of the basis functions <code>ϕi</code> (<code>i∈{0,...,N}</code>).</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/models/IsobeKakinuma.jl#L3-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.Matsuno_fast" href="#WaterWaves1D.Matsuno_fast"><code>WaterWaves1D.Matsuno_fast</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Matsuno_fast(param;dealias,label,verbose)</code></pre><p>Same as <code>Matsuno</code>, but faster.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/models/Matsuno.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.Mesh" href="#WaterWaves1D.Mesh"><code>WaterWaves1D.Mesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Mesh(args)</code></pre><p>Constructs a mesh of collocation points and associated Fourier modes.</p><p><strong>Arguments</strong></p><p>Can be either</p><ul><li><code>xmin</code>, <code>xmax</code>, and <code>N</code>; or</li><li><code>L</code>, <code>N</code> (same as above with <code>xmin=-L</code> and <code>xmax=L</code>); or</li><li><code>param :: NamedTuple</code>, a <code>NamedTuple</code> containing <code>N</code> and <code>L</code> or <code>xmin</code> and <code>xmax</code>, then same as above; or</li><li><code>x</code> a vector of regularly spaced collocation points`.</li></ul><p>The mesh as <code>N</code> collocation points regularly spaced between <code>xmin</code> (included) and <code>xmax</code> (excluded)</p><p><strong>Return values</strong></p><p><code>m=Mesh(args)</code> is of parametric type and offers with</p><ul><li><code>m.N</code>: number of collocation points and Fourier modes;</li><li><code>m.xmin</code>: minimum of the mesh (included in the vector of collocation points);</li><li><code>m.xmax</code>: maximum of the mesh (excluded in the vector of collocation points);</li><li><code>m.dx</code>: distance between two collocation points;</li><li><code>m.x</code>: the vector of collocation points;</li><li><code>m.kmin</code>: minimum of Fourier modes (included in the vector of Fourier modes);</li><li><code>m.kmax</code>: maximum of Fourier modes (included in the vector of Fourier modes);;</li><li><code>m.dk</code>: distance between two Fourier modes;</li><li><code>m.k</code>: the vector of Fourier modes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/mesh.jl#L3-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.NonHydrostatic" href="#WaterWaves1D.NonHydrostatic"><code>WaterWaves1D.NonHydrostatic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NonHydrostatic(param;kwargs)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for the &quot;Non-hydrostatic&quot; model proposed by <a href="https://doi.org/10.3934/dcdsb.2015.20.961">Bristeau, Mangeney, Sainte-Marie and Seguin</a></p><p><strong>Argument</strong></p><p><code>param</code> is of type <code>NamedTuple</code> and must contain</p><ul><li>dimensionless parameters <code>ϵ</code> (nonlinearity) and <code>μ</code> (dispersion);</li><li>numerical parameters to construct the mesh of collocation points as <code>mesh = Mesh(param)</code>.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>iterative</code>: solve the elliptic problem through GMRES if <code>true</code>, LU decomposition if <code>false</code> (default is <code>true</code>);</li><li><code>precond</code>: use a (left) preconditioner for GMRES if <code>true</code> (default), choose <code>precond</code> as the preconditioner if provided;</li><li><code>gtol</code>: relative tolerance of the GMRES algorithm (default is <code>1e-14</code>);</li><li><code>restart</code>: the corresponding option of the GMRES algorithm (default is <code>100</code>);</li><li><code>maxiter</code>: the corresponding option of GMRES (default is <code>nothing</code>);</li><li><code>ktol</code>: tolerance of the Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>dealias</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>label</code>: a label for future references (default is <code>&quot;non-hydrostatic&quot;</code>);</li><li><code>verbose</code>: prints information if <code>true</code> (default is <code>true</code>).</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>NonHydrostatic.f!</code> to be called in explicit time-integration solvers;</li><li>a function <code>NonHydrostatic.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>NonHydrostatic.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v)</code>, where<ul><li><code>η</code> is the surface deformation;</li><li><code>v</code> is the derivative of the trace of the velocity potential;</li></ul></li><li>additionally, a handy function <code>NonHydrostatic.mapfrofull</code> which from data matrix returns the Tuple of real vectors <code>(η,v,u)</code>, where<ul><li><code>u</code> corresponds to the layer-averaged velocity.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/models/NonHydrostatic.jl#L3-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.RK4_naive" href="#WaterWaves1D.RK4_naive"><code>WaterWaves1D.RK4_naive</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RK4_naive()</code></pre><p>Runge-Kutta fourth order solver.</p><p>A naive version of <code>RK4</code>, without argument since no pre-allocation is performed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/solvers/RK4.jl#L85-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.Random" href="#WaterWaves1D.Random"><code>WaterWaves1D.Random</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Random(;args)</code></pre><p>Randomly generated initial data, based on provided (optional arguments) :</p><ul><li><code>L</code> is the typical wavelength (default is <code>L=1</code>)</li><li><code>s</code> is the (real) Sobolev index regularity (default is <code>s=∞</code>)</li><li><code>λ</code> is the length of spatial localization (default is none)</li></ul><p>The initial data <code>(η,v)</code> are generated through randomly chosen Fourier coefficients, multiplied with weigth <code>w=10^(-|k|L/(2π))</code> if <code>s=∞</code>, or <code>w=1/(1+9(|k|L/(2π))^(s+1/2))</code> otherwise. If <code>λ</code> is provided, the function in spatial variables is multiplied by <code>exp(-|x/λ|^2)</code>, and in any case normalized to have maximum absolute value 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/initialdata/Random.jl#L3-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.SerreGreenNaghdi" href="#WaterWaves1D.SerreGreenNaghdi"><code>WaterWaves1D.SerreGreenNaghdi</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SerreGreenNaghdi(param;kwargs)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for the Serre-Green-Naghdi model</p><p><strong>Argument</strong></p><p><code>param</code> is of type <code>NamedTuple</code> and must contain</p><ul><li>dimensionless parameters <code>ϵ</code> (nonlinearity) and <code>μ</code> (dispersion);</li><li>numerical parameters to construct the mesh of collocation points as <code>mesh = Mesh(param)</code>.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>iterative</code>: solve the elliptic problem through GMRES if <code>true</code>, LU decomposition if <code>false</code> (default is <code>true</code>);</li><li><code>precond</code>: use a (left) preconditioner for GMRES if <code>true</code> (default), choose <code>precond</code> as the preconditioner if provided;</li><li><code>gtol</code>: relative tolerance of the GMRES algorithm (default is <code>1e-14</code>);</li><li><code>restart</code>: the corresponding option of the GMRES algorithm (default is <code>100</code>);</li><li><code>maxiter</code>: the corresponding option of GMRES (default is <code>nothing</code>);</li><li><code>ktol</code>: tolerance of the Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>dealias</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>label</code>: a label for future references (default is <code>&quot;Green-Naghdi&quot;</code>);</li><li><code>verbose</code>: prints information if <code>true</code> (default is <code>true</code>).</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>SerreGreenNaghdi.f!</code> to be called in explicit time-integration solvers;</li><li>a function <code>SerreGreenNaghdi.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>SerreGreenNaghdi.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v)</code>, where<ul><li><code>η</code> is the surface deformation;</li><li><code>v</code> is the derivative of the trace of the velocity potential;</li></ul></li><li>additionally, a handy function <code>SerreGreenNaghdi.mapfrofull</code> which from data matrix returns the Tuple of real vectors <code>(η,v,u)</code>, where<ul><li><code>u</code> corresponds to the layer-averaged velocity.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/models/SerreGreenNaghdi.jl#L3-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.SquareRootDepth" href="#WaterWaves1D.SquareRootDepth"><code>WaterWaves1D.SquareRootDepth</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SquareRootDepth(param;kwargs)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for the &quot;√D&quot; model proposed by <a href="https://doi.org/10.1098/rspa.2010.0124">Cotter, Holm and Percival</a></p><p><strong>Argument</strong></p><p><code>param</code> is of type <code>NamedTuple</code> and must contain</p><ul><li>dimensionless parameters <code>ϵ</code> (nonlinearity) and <code>μ</code> (dispersion);</li><li>numerical parameters to construct the mesh of collocation points as <code>mesh = Mesh(param)</code>.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>iterative</code>: solve the elliptic problem through GMRES if <code>true</code>, LU decomposition if <code>false</code> (default is <code>true</code>);</li><li><code>precond</code>: use a (left) preconditioner for GMRES if <code>true</code> (default), choose <code>precond</code> as the preconditioner if provided;</li><li><code>gtol</code>: relative tolerance of the GMRES algorithm (default is <code>1e-14</code>);</li><li><code>restart</code>: the corresponding option of the GMRES algorithm (default is <code>100</code>);</li><li><code>maxiter</code>: the corresponding option of GMRES (default is <code>nothing</code>);</li><li><code>ktol</code>: tolerance of the Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>dealias</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>label</code>: a label for future references (default is <code>&quot;square-root depth&quot;</code>);</li><li><code>verbose</code>: prints information if <code>true</code> (default is <code>true</code>).</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>SquareRootDepth.f!</code> to be called in explicit time-integration solvers;</li><li>a function <code>SquareRootDepth.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>SquareRootDepth.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v)</code>, where<ul><li><code>η</code> is the surface deformation;</li><li><code>v</code> is the derivative of the trace of the velocity potential;</li></ul></li><li>additionally, a handy function <code>SquareRootDepth.mapfrofull</code> which from data matrix returns the Tuple of real vectors <code>(η,v,u)</code>, where<ul><li><code>u</code> corresponds to the layer-averaged velocity.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/models/SquareRootDepth.jl#L3-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.Times" href="#WaterWaves1D.Times"><code>WaterWaves1D.Times</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Times(param; ns, Ns)</code></pre><p>Constructs a mesh of times, to be used in initial-value problems (see <code>Problem</code>).</p><p><strong>Arguments</strong></p><p><code>param</code> is either</p><ul><li><code>dt,T</code> with <code>dt</code> the timestep and <code>T</code> the final time of comuptation; or</li><li>a <code>NamedTuple</code> containing <code>dt</code> and <code>T</code></li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>ns</code>  : data are stored every <code>ns</code> computations (optional, default = 1).</li><li><code>Ns</code>  : <code>Ns</code> data (in addition to the initial datum) are stored (optional, by default `floor( tfin/dt)).</li></ul><p>If both <code>Ns</code> and <code>ns</code> are given, <code>Ns</code> overrules <code>ns</code>.</p><p><strong>Return values</strong></p><p><code>t=Times(args)</code> is of parametric type and offers</p><ul><li><code>t.Nc</code>: number of computed times (including initial datum);</li><li><code>t.Ns</code>: number of stored times (including initial datum);</li><li><code>t.ns</code>: number of computed times between two stored times;</li><li><code>t.tfin</code>: the final time;</li><li><code>t.dt</code>: the timestep;</li><li><code>t.tc</code> : the vector of computed times;</li><li><code>t.ts</code>: the vector of stored times.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/times.jl#L2-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.WWn" href="#WaterWaves1D.WWn"><code>WaterWaves1D.WWn</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WWn(param;kwargs)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for the water waves expansion proposed by Dommermuth and Yue (doi:10.1017/s002211208700288x), West et al. (doi:10.1029/jc092ic11p11803), Craig and Sulem (doi:10.1006/jcph.1993.1164) (see also the account by Choi : Fifth-order nonlinear spectral model for surface gravity waves: From pseudo-spectral to spectral formulations, RIMS Kokyuroku, 2019) with the &quot;rectification&quot; method proposed by Duchêne and Melinand.</p><p><strong>Argument</strong></p><p><code>param</code> is of type <code>NamedTuple</code> and must contain</p><ul><li>dimensionless parameters <code>ϵ</code> (nonlinearity) and <code>μ</code> (dispersion);</li><li>numerical parameters to construct the mesh of collocation points as <code>mesh = Mesh(param)</code></li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>ν</code>: shallow/deep water multiplication factor. By default, <code>ν=1</code> if <code>μ≦1</code> and <code>ν=1/√μ</code> otherwise. Set the infinite-layer case if <code>ν=0</code> (or <code>μ=Inf</code>).</li><li><code>IL</code>: Set the infinite-layer case if <code>IL=true</code> (or <code>μ=Inf</code>, or <code>ν=0</code>), in which case <code>ϵ</code> is the steepness parameter. Default is <code>false</code>.</li><li><code>n :: Int</code>: the order of the expansion; linear system if <code>1</code>, quadratic if <code>2</code>, cubic if <code>3</code>, quartic if <code>4</code> (default and other values yield <code>2</code>);</li><li><code>δ</code> and <code>m</code>: parameters of the rectifier operator, set as <code>k-&gt;min(1,|δ*k|^m)</code> or <code>k-&gt;min(1,|δ*k|^m[1]*exp(1-|δ*k|^m[2]))</code> if <code>m</code> is a couple</li></ul><p>(by default is <code>δ=0</code>, i.e. no regularization and <code>m=-1</code>. Notice <code>m=-Inf</code> and <code>δ&gt;0</code> yields a cut-off filter);</p><ul><li><code>ktol</code>: tolerance of the low-pass Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>dealias</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>label</code>: a label for future references (default is <code>&quot;WWn&quot;</code> with <code>n</code> the order of the expansion);</li><li><code>verbose</code>: prints information if <code>true</code> (default is <code>true</code>).</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>WWn.f!</code> to be called in explicit time-integration solvers (also <code>WWn.f1!</code> and <code>WWn.f2!</code> for the symplectic Euler solver);</li><li>a function <code>WWn.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>WWn.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v)</code>, where<ul><li><code>η</code> is the surface deformation;</li><li><code>v</code> is the derivative of the trace of the velocity potential.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/models/WWn.jl#L3-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.WaterWaves" href="#WaterWaves1D.WaterWaves"><code>WaterWaves1D.WaterWaves</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WaterWaves(param; kwargs)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for the water waves system (via conformal mapping, see <a href="https://doi.org/10.1016/S0997-7546(02)01189-5">Zakharov, Dyachenko and Vasilyev</a>).</p><p><strong>Argument</strong></p><p><code>param</code> is of type <code>NamedTuple</code> and must contain</p><ul><li>dimensionless parameters <code>ϵ</code> (nonlinearity) and <code>μ</code> (dispersion);</li><li>numerical parameters to construct the mesh of collocation points as <code>mesh = Mesh(param)</code>.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>ν</code>: shallow/deep water multiplication factor (see <a href="https://bookstore.ams.org/surv-188">Lannes, The water waves problem</a>). By default, <code>ν=1</code> if <code>μ≦1</code> and <code>ν=1/√μ</code> otherwise.</li><li><code>IL</code>: Set the infinite-layer case if <code>IL=true</code> (or <code>μ=Inf</code>, or <code>ν=0</code>), in which case <code>ϵ</code> is the steepness parameter. Default is <code>false</code>.</li><li><code>method ∈ {1,2,3}</code>: method used to initialize the conformal mapping, as a fix-point problem <code>F(u)=u</code><ul><li>if <code>method == 1</code>, use standard contraction fix-point iteration;</li><li>if <code>method == 2</code>, use Newton algorithm with GMRES iterative solver to invert the Jacobian;</li><li>if <code>method == 3</code>, use Newton algorithm with direct solver to invert the Jacobian;</li></ul></li><li><code>tol</code>: (relative) tolerance of the fix-point algorithm (default is <code>1e-16</code>);</li><li><code>maxiter</code>: the maximal number of iteration in the fix-point algorithm (default is <code>100</code>);</li><li><code>ktol</code>: tolerance of the low-pass Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>dealias</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>label</code>: a label for future references (default is <code>&quot;water waves&quot;</code>);</li><li><code>verbose</code>: prints information if <code>true</code> (default is <code>true</code>).</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>WaterWaves.f!</code> to be called in the explicit time-integration solver (also <code>WaterWaves.f1!</code> and <code>WaterWaves.f2!</code> for the symplectic Euler solver);</li><li>a function <code>WaterWaves.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>WaterWaves.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(x,η,v)</code>, where<ul><li><code>x</code> is a vector of collocation points (non-regularly spaced);</li><li><code>η</code> is the surface deformation at points <code>x</code>;</li><li><code>v</code> is the derivative of the trace of the velocity potential at points <code>x</code>.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/models/WaterWaves.jl#L3-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.WhithamBoussinesq" href="#WaterWaves1D.WhithamBoussinesq"><code>WaterWaves1D.WhithamBoussinesq</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WhithamBoussinesq(param;kwargs)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for a Boussinesq-type model with full-dispersion property.</p><p><strong>Argument</strong></p><p><code>param</code> is of type <code>NamedTuple</code> and must contain</p><ul><li>dimensionless parameters <code>ϵ</code> (nonlinearity) and <code>μ</code> (dispersion);</li><li>numerical parameters to construct the mesh of collocation points as <code>mesh = Mesh(param)</code></li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>Boussinesq</code>: if <code>true</code> (default is <code>false</code>), compute the standard Boussinesq system instead (see <code>Boussinesq(param;kwargs)</code>);</li><li>a parameter <code>α</code> which determines the model solved:<ul><li>If <code>α = 1</code> (default), then the model has been introduced in <a href="https://doi.org/10.1016/j.apnum.2018.09.016">Dinvay, Dutykh and Kalisch</a>;</li><li>If <code>α = 1/2</code>, then the model is a quasilinear version;</li><li>If <code>α &lt; 1/2</code>, then expect instabilities stemming from ill-posedness of the model.</li></ul></li><li><code>ktol</code>: tolerance of the low-pass Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>dealias</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>label</code>: a label for future references (default is <code>&quot;Whitham-Boussinesq&quot;</code>);</li><li><code>verbose</code>: prints information if <code>true</code> (default is <code>true</code>).</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>WhithamBoussinesq.f!</code> to be called in explicit time-integration solvers;</li><li>a function <code>WhithamBoussinesq.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed.</li><li>a function <code>WhithamBoussinesq.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v)</code>, where<ul><li><code>η</code> is the surface deformation;</li><li><code>v</code> is the derivative of the trace of the velocity potential.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/models/WhithamBoussinesq.jl#L3-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.WhithamGreenNaghdi" href="#WaterWaves1D.WhithamGreenNaghdi"><code>WaterWaves1D.WhithamGreenNaghdi</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WhithamGreenNaghdi(param;kwargs)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for the fully dispersive Green-Naghdi model proposed by <a href="https://doi.org/10.1137/130947064">Duchêne, Israwi and Talhouk</a>.</p><p><strong>Argument</strong></p><p><code>param</code> is of type <code>NamedTuple</code> and must contain</p><ul><li>dimensionless parameters <code>ϵ</code> (nonlinearity) and <code>μ</code> (dispersion);</li><li>numerical parameters to construct the mesh of collocation points as <code>mesh = Mesh(param)</code>.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>SGN</code>: if <code>true</code> (default is <code>false</code>), compute the Serre-Green-Naghdi (SGN) instead of Whitham-Green-Naghdi (WGN) system (see <code>SerreGreenNaghdi(param;kwargs)</code>);</li><li><code>iterative</code>: solve the elliptic problem through GMRES if <code>true</code>, LU decomposition if <code>false</code> (default is <code>true</code>);</li><li><code>precond</code>: use a (left) preconditioner for GMRES if <code>true</code> (default), choose <code>precond</code> as the preconditioner if provided;</li><li><code>gtol</code>: relative tolerance of the GMRES algorithm (default is <code>1e-14</code>);</li><li><code>restart</code>: the corresponding option of the GMRES algorithm (default is <code>100</code>);</li><li><code>maxiter</code>: the corresponding option of GMRES (default is <code>nothing</code>);</li><li><code>ktol</code>: tolerance of the Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>dealias</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>label</code>: a label for future references (default is <code>&quot;Whitham-Green-Naghdi&quot;</code>);</li><li><code>verbose</code>: prints information if <code>true</code> (default is <code>true</code>).</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>WhithamGreenNaghdi.f!</code> to be called in explicit time-integration solvers;</li><li>a function <code>WhithamGreenNaghdi.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>WhithamGreenNaghdi.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v)</code>, where<ul><li><code>η</code> is the surface deformation;</li><li><code>v</code> is the derivative of the trace of the velocity potential;</li></ul></li><li>additionally, a handy function <code>WhithamGreenNaghdi.mapfrofull</code> which from data matrix returns the Tuple of real vectors <code>(η,v,u)</code>, where<ul><li><code>u</code> corresponds to the layer-averaged velocity.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/models/WhithamGreenNaghdi.jl#L3-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.modifiedMatsuno" href="#WaterWaves1D.modifiedMatsuno"><code>WaterWaves1D.modifiedMatsuno</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">modifiedMatsuno(param;kwargs)</code></pre><p>Define an object of type <code>AbstractModel</code> in view of solving the initial-value problem for the modified Matsuno model</p><p><strong>Argument</strong></p><p><code>param</code> is of type <code>NamedTuple</code> and must contain</p><ul><li>dimensionless parameters <code>ϵ</code> (nonlinearity) and <code>μ</code> (dispersion);</li><li>numerical parameters to construct the mesh of collocation points as <code>mesh = Mesh(param)</code></li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>ν</code>: shallow/deep water multiplication factor. By default, <code>ν=1</code> if <code>μ≦1</code> and <code>ν=1/√μ</code> otherwise. Set the infinite-layer case if <code>ν=0</code> (or <code>μ=Inf</code>).</li><li><code>IL</code>: Set the infinite-layer case if <code>IL=true</code> (or <code>μ=Inf</code>, or <code>ν=0</code>), in which case <code>ϵ</code> is the steepness parameter. Default is <code>false</code>.</li><li><code>ktol</code>: tolerance of the low-pass Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>dealias</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>label</code>: a label for future references (default is <code>&quot;modified Matsuno&quot;</code>);</li><li><code>verbose</code>: prints information if <code>true</code> (default is <code>true</code>).</li></ul><p><strong>Return values</strong></p><p>Generate necessary ingredients for solving an initial-value problem via <code>solve!</code>:</p><ol><li>a function <code>modifiedMatsuno.f!</code> to be called in explicit time-integration solvers;</li><li>a function <code>modifiedMatsuno.mapto</code> which from <code>(η,v)</code> of type <code>InitialData</code> provides the raw data matrix on which computations are to be executed;</li><li>a function <code>modifiedMatsuno.mapfro</code> which from such data matrix returns the Tuple of real vectors <code>(η,v)</code>, where<ul><li><code>η</code> is the surface deformation;</li><li><code>v</code> is the derivative of the trace of the velocity potential.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/models/modifiedMatsuno.jl#L3-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.CnoidalWaveSerreGreenNaghdi-Tuple{NamedTuple}" href="#WaterWaves1D.CnoidalWaveSerreGreenNaghdi-Tuple{NamedTuple}"><code>WaterWaves1D.CnoidalWaveSerreGreenNaghdi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CnoidalWaveSerreGreenNaghdi(param; P)</code></pre><p>Compute the Serre-Green-Naghdi cnoidal wave with prescribed <code>h₀&lt;h₁&lt;h₂</code>. <code>h_1</code> is the minimum, <code>h_2</code> is the maximum of the wave. As <code>h₀ -&gt; h₁</code>, the cnoidal wave converges towards the solitary wave. See for instance Gavrilyuk, Nkonga, Shyue and Truskinovsky, doi:10.1088/1361-6544/ab95ac</p><p><strong>Arguments</strong></p><ul><li><code>param :: NamedTuple</code>: parameters of the problem containing <code>h₀&lt;h₁&lt;h₂</code> and dimensionless parameters <code>ϵ</code> and <code>μ</code>, and number of collocation points <code>N</code>.</li><li><code>P :: Int</code>: (keyword, optional, default = 2) the number of periods of the cnoidal wave in the constructed mesh.</li></ul><p><strong>Return values</strong></p><p><code>(η,u,v,mesh,param)</code> with</p><ul><li><code>η :: Vector{Float64}</code>: surface deformation;</li><li><code>u :: Vector{Float64}</code>: layer-averaged velocity;</li><li><code>v :: Vector{Float64}</code>: tangential velocity;</li><li><code>mesh :: Mesh</code>: mesh collocation points;</li><li><code>param :: NamedTuple</code>: useful parameters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/initialdata/CnoidalWaveSerreGreenNaghdi.jl#L4-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.SolitaryWaveSerreGreenNaghdi-Tuple{NamedTuple}" href="#WaterWaves1D.SolitaryWaveSerreGreenNaghdi-Tuple{NamedTuple}"><code>WaterWaves1D.SolitaryWaveSerreGreenNaghdi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SolitaryWaveSerreGreenNaghdi(param; kwargs...)</code></pre><p>Compute the Serre-Green-Naghdi solitary wave with prescribed velocity.</p><p><strong>Arguments</strong></p><ul><li><code>param :: NamedTuple</code>: parameters of the problem containing velocity <code>c</code> and dimensionless parameters <code>ϵ</code> and <code>μ</code>, and mesh size <code>L</code> and number of collocation points <code>N</code>;</li><li><code>x₀ :: Real</code>: (keyword, optional, default = 0) center of solitary wave.</li></ul><p><strong>Return values</strong></p><p><code>(η,u,v)</code> with</p><ul><li><code>η :: Vector{Float64}</code>: surface deformation;</li><li><code>u :: Vector{Float64}</code>: layer-averaged velocity;</li><li><code>v :: Vector{Float64}</code>: tangential velocity;</li><li><code>mesh :: Mesh</code>: mesh collocation points.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/initialdata/SolitaryWaveSerreGreenNaghdi.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.SolitaryWaveWhitham-Tuple{NamedTuple}" href="#WaterWaves1D.SolitaryWaveWhitham-Tuple{NamedTuple}"><code>WaterWaves1D.SolitaryWaveWhitham</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">`SolitaryWaveWhitham(param; kwargs...)`</code></pre><p>Computes the Whitham solitary wave with prescribed velocity.</p><p><strong>Argument</strong></p><ul><li><code>param :: NamedTuple</code>: parameters of the problem containing velocity <code>c</code> and dimensionless parameters <code>ϵ</code> and <code>μ</code>, and mesh size <code>L</code> and number of collocation points <code>N</code>;</li></ul><p><strong>Keywords (optional)</strong></p><ul><li><code>guess :: Vector{Real}</code>: initial guess for the surface deformation (if not provided, the exact formula for KdV is used);</li><li><code>x₀ :: Real</code>: center of solitary wave (if guess is not provided);</li><li><code>iterative :: Bool</code>: inverts Jacobian through GMRES if <code>true</code>, LU decomposition if <code>false</code>;</li><li><code>verbose :: Bool</code>: prints numerical errors at each step if <code>true</code>;</li><li><code>max_iter :: Int</code>: maximum number of iterations of the Newton algorithm;</li><li><code>tol :: Real</code>: general tolerance (default is <code>1e-10</code>);</li><li><code>ktol :: Real</code>: tolerance of the Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>gtol :: Real</code>: relative tolerance of the GMRES algorithm;</li><li><code>dealias :: Int</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>q :: Real</code>: Newton algorithm modified with</li></ul><p><code>u_{n+1}=q*u_{n+1}+(1-q)*u_n</code> (default is <code>1</code>);</p><ul><li><code>α :: Real</code>: adds <code>α</code> times spectral projection onto the Kernel to the Jacobian;</li><li><code>KdV :: Bool</code>: if <code>true</code> computes the KdV (instead of Whitham) solitary wave.</li></ul><p><strong>Return values</strong></p><p><code>u :: Vector{Float64}</code> the solution</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/initialdata/SolitaryWaveWhitham.jl#L3-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.SolitaryWaveWhithamBoussinesq-Tuple{NamedTuple}" href="#WaterWaves1D.SolitaryWaveWhithamBoussinesq-Tuple{NamedTuple}"><code>WaterWaves1D.SolitaryWaveWhithamBoussinesq</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">`SolitaryWaveWhithamBoussinesq(param; kwargs...)`</code></pre><p>Computes the Whitham-Boussinesq solitary wave with prescribed velocity.</p><p><strong>Argument</strong></p><ul><li><code>param :: NamedTuple</code>: parameters of the problem containing velocity <code>c</code> and dimensionless parameters <code>ϵ</code> and <code>μ</code>, and mesh size <code>L</code> and number of collocation points <code>N</code>;</li></ul><p><strong>Keywords (optional)</strong></p><ul><li><code>guess :: Vector{Real}</code>: initial guess for the surface deformation (if not provided, the exact formula for SGN is used);</li><li><code>x₀ :: Real</code>: center of solitary wave (if guess is not provided);</li><li><code>model :: Real</code>: determines the model used (typically <code>1</code> or <code>1/2</code>, default is 1);</li><li><code>iterative :: Bool</code>: inverts Jacobian through GMRES if <code>true</code>, LU decomposition if <code>false</code>;</li><li><code>verbose :: Bool</code>: prints numerical errors at each step if <code>true</code>;</li><li><code>max_iter :: Int</code>: maximum number of iterations of the Newton algorithm;</li><li><code>tol :: Real</code>: general tolerance (default is <code>1e-10</code>);</li><li><code>ktol :: Real</code>: tolerance of the Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>gtol :: Real</code>: relative tolerance of the GMRES algorithm;</li><li><code>dealias :: Int</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>q :: Real</code>: Newton algorithm modified with</li></ul><p><code>u_{n+1}=q*u_{n+1}+(1-q)*u_n</code> (default is <code>1</code>);</p><ul><li><code>α :: Real</code>: adds <code>α</code> times spectral projection onto the Kernel to the Jacobian.</li></ul><p><strong>Return values</strong></p><p><code>(η,u) :: Tuple{Vector{Float64},Vector{Float64}}</code> with</p><ul><li><code>η</code>: surface deformation;</li><li><code>u</code>: velocity.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/initialdata/SolitaryWaveWhithamBoussinesq.jl#L3-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.SolitaryWaveWhithamGreenNaghdi-Tuple{NamedTuple}" href="#WaterWaves1D.SolitaryWaveWhithamGreenNaghdi-Tuple{NamedTuple}"><code>WaterWaves1D.SolitaryWaveWhithamGreenNaghdi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SolitaryWaveWhithamGreenNaghdi(param; kwargs...)</code></pre><p>Compute the Whitham-Green-Naghdi solitary wave with prescribed velocity.</p><p><strong>Arguments</strong></p><ul><li><code>param :: NamedTuple</code>: parameters of the problem containing velocity <code>c</code> and dimensionless parameters <code>ϵ</code> and <code>μ</code>, and mesh size <code>L</code> and number of collocation points <code>N</code>;</li></ul><p><strong>Keywords (optional)</strong></p><ul><li><code>guess :: Vector{Real}</code>: initial guess for the surface deformation (if not provided, the exact formula for SGN is used);</li><li><code>x₀ :: Real</code>: center of solitary wave (if guess is not provided);</li><li><code>SGN :: Bool</code>: if <code>true</code> computes the Serre-Green-Naghdi (instead of Whitham-Green-Naghdi) solitary wave (consider <code>SolitaryWaveSerreGreenNaghdi</code> instead);</li><li><code>method :: Int</code>: equation used (between <code>1</code> and <code>4</code>);</li><li><code>iterative :: Bool</code>: inverts Jacobian through GMRES if <code>true</code>, LU decomposition if <code>false</code> (default is <code>false</code>);</li><li><code>verbose :: Bool</code>: prints numerical errors at each step if <code>true</code> (default is <code>false</code>);</li><li><code>max_iter :: Int</code>: maximum number of iterations of the Newton algorithm (default is <code>20</code>);</li><li><code>tol :: Real</code>: relative tolerance measured in ℓ∞ norm (default is <code>1e-10</code>);</li><li><code>ktol :: Real</code>: tolerance of the Krasny filter (default is <code>0</code>, i.e. no filtering);</li><li><code>gtol :: Real</code>: relative tolerance of the GMRES algorithm (default is <code>1e-10</code>);</li><li><code>dealias :: Int</code>: dealiasing with Orlicz rule <code>1-dealias/(dealias+2)</code> (default is <code>0</code>, i.e. no dealiasing);</li><li><code>q :: Real</code>: Newton algorithm modified with <code>u_{n+1}=q*u_{n+1}+(1-q)*u_n</code> (default is <code>1</code>);</li><li><code>α :: Real</code>: adds <code>α</code> times spectral projection onto the Kernel to the Jacobian (default is <code>0</code>).</li></ul><p><strong>Return values</strong></p><p><code>(η,u,v)</code> with</p><ul><li><code>η :: Vector{Float64}</code>: surface deformation;</li><li><code>u :: Vector{Float64}</code>: layer-averaged velocity;</li><li><code>v :: Vector{Float64}</code>: tangential velocity;</li><li><code>mesh :: Mesh</code>: mesh collocation points.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/initialdata/SolitaryWaveWhithamGreenNaghdi.jl#L3-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.create_animation-Tuple{Any}" href="#WaterWaves1D.create_animation-Tuple{Any}"><code>WaterWaves1D.create_animation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_animation( problems; name::String, kwargs... )</code></pre><p>Create an animation showing the evolution of initial-value problems.</p><p>Argument <code>problems</code> is either an element or a collection (vector, list, etc.) of elements of type <code>Problem</code>.</p><p>The animation is saved as <code>name.gif</code> if <code>name</code> is provided.</p><p>Other keyword arguments are as follows</p><ul><li><code>xlims</code> allows to specifies the x axis limits for the surface deformation. If <code>nothing</code> is provided (default), then the full numerical basin is represented.</li><li><code>ylims</code> allows to specifies the y axis limits for the surface deformation. If <code>nothing</code> is provided (default), then the limits are determined from the initial data. If anything but a <code>Tuple</code> is provided, the axis limits evolve with the solution.</li><li><code>vlims</code> and <code>flims</code> are as above, but for the velocity and Fourier coefficients plots.</li><li><code>Nframes</code> gives the (maximal) number of frames in the animation.</li><li>other arguments of <code>plot_solution!</code></li></ul><p>Return <code>anim</code>, an animation, which can then generate (for instance) a <code>gif</code> through <code>gif(anim, &quot;my_name.gif&quot;, fps=15)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/figures.jl#L4-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.interpolate-Tuple{Mesh, Any, Any}" href="#WaterWaves1D.interpolate-Tuple{Mesh, Any, Any}"><code>WaterWaves1D.interpolate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interpolate(mesh,vector,x;fast)</code></pre><p>Interpolate a vector <code>vector</code> defined on a uniform collocation grid defined by <code>mesh</code>, on collocation points given by <code>x</code>.</p><p>If the collocation points <code>x</code> are regularly spaced and the optional keyword argument <code>fast</code> is set to <code>true</code> (default is <code>false</code>), then the algorithm is faster and uses less allocations, but is less precise.</p><p>Returns the vector of values on collocation points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/tools.jl#L26-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.interpolate-Tuple{Mesh, Any}" href="#WaterWaves1D.interpolate-Tuple{Mesh, Any}"><code>WaterWaves1D.interpolate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interpolate(mesh,vector;n=2^3)</code></pre><p>Interpolate a vector <code>vector</code> defined on a uniform collocation grid defined by <code>mesh</code>.</p><p>Returns <code>(new_mesh,new_vector)</code> a new uniform mesh with <code>n</code> times as many values, and the vector of values on collocation points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/tools.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.plot_difference!-Tuple{Any, Any}" href="#WaterWaves1D.plot_difference!-Tuple{Any, Any}"><code>WaterWaves1D.plot_difference!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_difference!( plt, problems ; t,x,interpolation,compression,fast,surface,velocity,fourier,label )</code></pre><p>Plots in <code>plt</code> the difference between solutions of initial-value problems at a given time.</p><p><strong>Argument</strong></p><p><code>pairs</code> is a either a collection (vector, list, etc.) of elements of type <code>Problem</code>, or of pairs of such elements. If pairs are provided, then solutions of such problems are compared. If a collection of problems are provided, then all possible pairs are compared.</p><p><strong>Keyword arguments (all optional)</strong></p><ul><li><code>t</code> is the time. If not provided, then the last computed time is plotted.</li><li>if a vector <code>x</code> is provided and if possible, the solution is interpolated to the collocation points <code>x</code>.</li><li>if <code>interpolation</code> is provided as an integer, the solution is interpolated on as many collocation points (if <code>true</code>, then the value <code>2^3</code> is chosen, default is <code>false</code>).</li><li>if <code>fast = false</code> (default is <code>false</code>), then the second problem is interpolated to the collocation points of the first problem.</li><li>if <code>compression</code> is provided as an integer <code>m</code>, only one in <code>m</code> points are plotted (if <code>true</code>, then the value <code>2^3</code> is chosen, default is <code>false</code>).</li><li><code>surface</code>, <code>velocity</code> and <code>fourier</code> (booleans) determine respectively whether surface deformation, <code>η</code>, tangential velocity, <code>v</code>, and the Fourier coefficients of <code>η</code> (in log-scale) are plotted.</li><li><code>label</code> defines the label(s) if provided (otherwise labels are inferred from the problems).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/figures.jl#L175-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.plot_difference-Tuple{Any}" href="#WaterWaves1D.plot_difference-Tuple{Any}"><code>WaterWaves1D.plot_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_difference( pairs; t,x, interpolation,compression, surface,velocity,fourier, label )</code></pre><p>Same as <code>plot_difference!</code> but generates and returns the plot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/figures.jl#L271-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.plot_solution!-Tuple{Any, Any}" href="#WaterWaves1D.plot_solution!-Tuple{Any, Any}"><code>WaterWaves1D.plot_solution!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_solution!( plt; problems; t,x,interpolation,compression,surface,velocity,fourier,label )</code></pre><p>Plots in <code>plt</code> the solution of initial-value problems at a given time.</p><p><strong>Argument</strong></p><p><code>problems</code> is either an element or a collection (vector, list, etc.) of elements of type <code>Problem</code>.</p><p><strong>Keyword arguments (all optional)</strong></p><ul><li><code>t</code> is the time. If not provided, then the last computed time is plotted.</li><li>if a vector <code>x</code> is provided and if possible, the solution is interpolated to the collocation points <code>x</code>.</li><li>if <code>interpolation</code> is provided as an integer, the solution is interpolated on as many collocation points (if <code>true</code>, then the value <code>2^3</code> is chosen, default is <code>false</code>).</li><li>if <code>compression</code> is provided as an integer <code>m</code>, only one in <code>m</code> points are plotted (if <code>true</code>, then the value <code>2^3</code> is chosen, default is <code>false</code>).</li><li><code>surface</code>, <code>velocity</code> and <code>fourier</code> (booleans) determine respectively whether surface deformation, <code>η</code>, tangential velocity, <code>v</code>, and the Fourier coefficients of <code>η</code> (in log-scale) are plotted.</li><li><code>label</code> defines the label(s) if provided (otherwise labels are inferred from the problems)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/figures.jl#L90-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.plot_solution-Tuple{Any}" href="#WaterWaves1D.plot_solution-Tuple{Any}"><code>WaterWaves1D.plot_solution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_solution( problems; t,x, interpolation,compression, surface,velocity,fourier, label )</code></pre><p>Same as <code>plot_solution!</code> but generates and returns the plot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/figures.jl#L164-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.solution-Tuple{Problem}" href="#WaterWaves1D.solution-Tuple{Problem}"><code>WaterWaves1D.solution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solution(p::Problem;t,x,interpolation)</code></pre><p>Gives the solution of a solved initial-value at a given time <code>t</code>.</p><p><strong>Arguments</strong></p><ul><li>Argument <code>p</code> is of type <code>Problem</code>.</li><li>Keyword argument <code>t</code> is optional, the last computed time is returned by default.</li><li>Keyword argument <code>x</code> is optional, if provided the solution is interpolated to the collocation vector <code>x</code>.</li><li>Keyword argument <code>interpolation</code> is optional, if an integer is provided the solution is interpolated on as many collocation points (if <code>true</code>, then the default value <code>2^3</code> is chosen).</li></ul><p><strong>Return values</strong></p><p>Provides <code>(η,v,x,t)</code> where</p><ul><li><code>η</code> is the surface deformation at collocation points;</li><li><code>v</code> is the tangential velocity (derivative of the trace of the velocity potential) at collocation points;</li><li><code>x</code> is the vector of collocation points;</li><li><code>t</code> the time (first computed time greater or equal to provided <code>t</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/tools.jl#L70-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WaterWaves1D.solve!-Tuple{Any}" href="#WaterWaves1D.solve!-Tuple{Any}"><code>WaterWaves1D.solve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve!( problems; verbose=true )</code></pre><p>Solve (i.e. integrate in time) a collection of initial-value problems.</p><p>The argument <code>problems</code> should be a collection (list, array...) of elements of type <code>Problem</code>.</p><p>Information are not printed if keyword argument <code>verbose = false</code> (default is <code>true</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaterWavesModels/WaterWaves1D.jl/blob/8064ae0ab9f19f623964a2ef1855247c08f81da4/src/problem.jl#L148-L156">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="quickstart/">« Quickstart</a><a class="docs-footer-nextpage" href="basics/">Code basics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Friday 28 January 2022 09:05">Friday 28 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
